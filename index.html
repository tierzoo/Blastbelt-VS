<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Blast Belt Versus</title>
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Blast Belt Versus">
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    font-family: 'Share Tech Mono', monospace;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    width: 100vw;
  }
  #game-container {
    position: relative;
    aspect-ratio: 9/16;
    max-height: 100vh;
    max-width: 100vw;
    overflow: hidden;
    background: #000;
  }
  canvas { display: block; width: 100%; height: 100%; }

  /* â”€â”€ SETUP SCREEN â”€â”€ */
  #setup-screen {
    position: absolute; inset: 0; z-index: 100;
    display: flex; flex-direction: column; align-items: center;
    background: radial-gradient(ellipse at 50% 30%, rgba(20,10,40,0.95) 0%, #000 70%);
    overflow-y: auto; overflow-x: hidden;
    padding: 3% 3% 5% 3%;
  }
  #setup-screen.hidden { display: none; }
  .setup-title {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(22px, 5vw, 36px);
    font-weight: 900;
    letter-spacing: 6px;
    text-align: center;
    background: linear-gradient(135deg, #fff 0%, #8af 50%, #f8f 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin-bottom: 2px;
  }
  .setup-sub {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(8px, 2vw, 11px);
    letter-spacing: 6px;
    color: rgba(255,255,255,0.35);
    margin-bottom: 10px;
  }

  /* Mode selector */
  .mode-selector {
    display: flex; gap: 6px; margin-bottom: 12px;
  }
  .mode-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(9px, 2vw, 12px);
    font-weight: 700;
    letter-spacing: 3px;
    padding: 8px 16px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
  }
  .mode-btn.active {
    background: rgba(255,120,60,0.2);
    border-color: rgba(255,120,60,0.6);
    color: #ff8844;
  }
  .mode-btn:hover { border-color: rgba(255,255,255,0.4); }

  /* Team columns */
  .teams-area {
    display: flex; gap: 4px; width: 100%; flex: 1; min-height: 0; flex-wrap: wrap;
  }
  .team-col {
    flex: 1; display: flex; flex-direction: column;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 6px;
    padding: 6px;
    min-height: 60px;
    min-width: 0;
  }
  .team-header {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(7px, 1.5vw, 9px);
    font-weight: 700;
    letter-spacing: 2px;
    text-align: center;
    padding: 3px 0 4px 0;
    cursor: text;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .team-slots { display: flex; flex-direction: column; gap: 4px; flex: 1; overflow-y: auto; }
  .team-wpn-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(6px, 1.3vw, 8px);
    padding: 2px 4px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 3px;
    background: rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
    text-align: center;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .team-wpn-btn.active { color: rgba(68,255,136,0.8); border-color: rgba(68,255,136,0.3); }
  .team-wpn-dropdown {
    position: absolute; z-index: 200;
    background: rgba(10,5,20,0.96);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 4px;
    padding: 4px;
    max-height: 260px;
    overflow-y: auto;
    min-width: 120px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.8);
  }
  .team-wpn-item {
    display: flex; align-items: center; gap: 6px;
    padding: 3px 6px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.6);
    cursor: pointer;
    border-radius: 2px;
  }
  .team-wpn-item:hover { background: rgba(255,255,255,0.06); }
  .team-wpn-item input[type="checkbox"] { margin: 0; accent-color: #44ff88; }
  .team-slot {
    display: flex; align-items: center; gap: 6px;
    padding: 5px 8px;
    border: 1px dashed rgba(255,255,255,0.1);
    border-radius: 4px;
    min-height: 36px;
    transition: all 0.2s;
    cursor: pointer;
  }
  .team-slot.filled {
    border-style: solid;
    background: rgba(255,255,255,0.03);
  }
  .team-slot .slot-name {
    font-size: clamp(9px, 2vw, 11px);
    letter-spacing: 2px;
    flex: 1;
  }
  .team-slot .slot-info {
    font-size: clamp(6px, 1.4vw, 8px);
    color: rgba(255,255,255,0.3);
  }
  .team-slot .slot-remove {
    font-size: 10px;
    color: rgba(255,255,255,0.3);
    cursor: pointer;
  }
  .team-slot .slot-remove:hover { color: #ff4444; }
  .team-slot.empty .slot-name {
    color: rgba(255,255,255,0.15);
    font-style: italic;
  }

  /* Ship roster grid */
  .roster-label {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(7px, 1.5vw, 9px);
    letter-spacing: 4px;
    color: rgba(255,255,255,0.3);
    text-align: center;
    margin: 10px 0 6px 0;
  }
  .roster-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    width: 100%;
  }
  .roster-ship {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    padding: 5px 2px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    background: rgba(0,0,0,0.3);
    min-height: 48px;
  }
  .roster-ship:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.3); }
  .roster-ship.selected { background: rgba(68,255,136,0.1); border-color: rgba(68,255,136,0.5); }
  .roster-ship .ship-icon { width: 20px; height: 20px; }
  .teams-area.hidden { display: none !important; }
  .roster-ship .rs-name {
    font-size: clamp(6px, 1.4vw, 8px);
    letter-spacing: 1px;
    margin-top: 2px;
  }

  /* Settings row */
  .setup-settings {
    display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
    margin: 8px 0;
    width: 100%;
  }
  .ss-toggle {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(7px, 1.5vw, 9px);
    padding: 4px 8px;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 3px;
    background: rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.35);
    cursor: pointer;
    transition: all 0.2s;
  }
  .ss-toggle.on {
    background: rgba(68,255,136,0.12);
    border-color: rgba(68,255,136,0.4);
    color: #44ff88;
  }
  .ss-toggle:hover { border-color: rgba(255,255,255,0.3); }

  .hp-row {
    display: flex; gap: 3px; justify-content: center; margin: 4px 0;
  }
  .hp-btn2 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(8px, 1.6vw, 10px);
    font-weight: 700;
    padding: 4px 10px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.4);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .hp-btn2.active {
    background: rgba(68,255,136,0.2);
    border-color: rgba(68,255,136,0.5);
    color: #44ff88;
  }

  .setup-bottom {
    display: flex; gap: 8px; width: 80%; margin-top: 10px;
  }
  #auto-fill-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(9px, 2vw, 11px);
    padding: 10px 12px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.5);
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
    white-space: nowrap;
  }
  #auto-fill-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.4); }
  #start-match-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(11px, 2.5vw, 14px);
    font-weight: 700;
    letter-spacing: 6px;
    padding: 12px 30px;
    background: rgba(255,120,60,0.15);
    border: 2px solid rgba(255,120,60,0.5);
    color: #ff8844;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.3s;
    flex: 1;
  }
  #start-match-btn:hover {
    background: rgba(255,120,60,0.3);
    border-color: #ff8844;
    box-shadow: 0 0 20px rgba(255,120,60,0.3);
  }
  #start-match-btn:disabled {
    opacity: 0.3;
    pointer-events: none;
  }

  /* â”€â”€ COUNTDOWN â”€â”€ */
  #countdown-overlay {
    position: absolute; inset: 0; z-index: 100;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,0.92);
    pointer-events: none;
    padding: 5% 5% 5% 5%;
    overflow: hidden;
  }
  #countdown-overlay.hidden { display: none; }
  .cd-title {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(18px, 5vw, 32px);
    font-weight: 700;
    color: #fff;
    letter-spacing: 2px;
    margin-bottom: 12px;
    text-align: center;
    flex-shrink: 0;
    word-wrap: break-word;
    max-width: 95%;
    line-height: 1.4;
  }
  .cd-fighters {
    display: flex; flex-direction: column;
    gap: 10px;
    width: 100%; max-width: 400px;
    flex-shrink: 1;
    justify-content: center;
    overflow: hidden;
  }
  .cd-fighter-row {
    display: flex; align-items: center; gap: 10px;
    padding: 6px 0;
    animation: cdSlideIn 0.4s ease-out backwards;
  }
  @keyframes cdSlideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  .cd-fighter-row .ship-icon { width: 32px; height: 32px; flex-shrink: 0; }
  .cd-fighter-info {
    display: flex; flex-direction: column; gap: 1px;
  }
  .cd-fighter-name {
    font-size: clamp(12px, 3vw, 16px);
    letter-spacing: 2px;
    font-weight: 700;
  }
  .cd-fighter-loadout {
    font-size: clamp(8px, 2vw, 11px);
    color: rgba(255,255,255,0.4);
    letter-spacing: 1px;
  }
  .cd-bottom {
    margin-top: 12px;
    flex-shrink: 0;
    text-align: center;
  }
  #cd-timer {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(14px, 3.5vw, 22px);
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    letter-spacing: 3px;
    animation: pulse 1s ease-in-out infinite;
  }
  @keyframes pulse { 0%,100% { opacity:0.5; } 50% { opacity:1; } }

  /* â”€â”€ MATCH HUD â”€â”€ */
  #match-hud { display: none !important; }
  .hud-team {
    position: absolute; left: 0; right: 0;
    display: flex; gap: 4px; padding: 6px 8px;
    justify-content: center;
  }
  .hud-team.top { top: 0; }
  .hud-team.bottom { bottom: 0; }
  .hud-ship {
    display: flex; align-items: center; gap: 4px;
    padding: 3px 8px;
    background: rgba(0,0,0,0.6);
    border-radius: 3px;
    border: 1px solid;
    transition: opacity 0.3s;
  }
  .hud-ship.dead { opacity: 0.25; }
  .hud-ship .ship-icon { width: 16px; height: 16px; }
  .hud-ship .hs-name {
    font-size: clamp(8px, 1.8vw, 10px);
    letter-spacing: 2px;
  }
  .hud-ship .hs-hp-bar {
    width: 40px; height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
  }
  .hud-ship .hs-hp-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.15s;
  }
  .hud-ship .hs-kills {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    font-weight: 700;
  }

  #killfeed { display: none; }
  .kill-msg { display: none; }

  #match-timer { display: none; }

  /* â”€â”€ WINNER â”€â”€ */
  #winner-overlay {
    position: absolute; inset: 0; z-index: 100;
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,0.88);
    backdrop-filter: blur(8px);
    padding: 20px;
    overflow: hidden;
  }
  #winner-overlay.show { display: flex; animation: fadeIn 1s ease; }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }
  #winner-label {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(17px, 4.2vw, 24px);
    letter-spacing: 14px;
    color: rgba(255,255,255,0.4);
    margin-bottom: 12px;
  }
  #winner-name {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(48px, 13.6vw, 88px);
    font-weight: 900;
    text-shadow: 0 0 60px currentColor;
    margin-bottom: 24px;
    text-align: center;
  }
  .result-card {
    display: flex; align-items: center; gap: 14px;
    padding: 14px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    width: 90%; max-width: 578px;
    opacity: 0;
    animation: slideIn 0.4s ease forwards;
  }
  @keyframes slideIn { from{opacity:0;transform:translateX(-15px)} to{opacity:1;transform:translateX(0)} }
  .result-card .rc-rank {
    font-family: 'Orbitron', sans-serif;
    font-size: 27px; font-weight: 900;
    width: 41px; text-align: right;
    color: rgba(255,255,255,0.3);
  }
  .result-card:nth-child(1) .rc-rank { color: #ffd700; }
  .result-card:nth-child(2) .rc-rank { color: #c0c0c0; }
  .result-card .ship-icon { width: 48px; height: 48px; }
  .result-card .rc-info { flex: 1; display: flex; flex-direction: column; gap: 2px; }
  .result-card .rc-name {
    font-size: clamp(19px, 4.2vw, 24px);
    letter-spacing: 3px;
  }
  .result-card .rc-loadout {
    font-size: clamp(12px, 2.5vw, 15px);
    color: rgba(255,255,255,0.3);
    letter-spacing: 2px;
  }
  .result-card .rc-stats-col {
    min-width: 95px; flex-shrink: 0;
    display: flex; flex-direction: column; align-items: flex-end; gap: 2px;
  }
  .result-card .rc-stats {
    font-family: 'Orbitron', sans-serif;
    font-size: 17px; font-weight: 700;
  }
  .result-card .rc-cause {
    font-size: 14px;
    color: rgba(255,255,255,0.3);
  }
  #rematch-btn, #new-setup-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(17px, 3.7vw, 22px);
    font-weight: 700;
    letter-spacing: 8px;
    padding: 17px 48px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.3);
    color: #fff;
    cursor: pointer;
    transition: all 0.3s;
    margin-top: 20px;
    border-radius: 4px;
  }
  #rematch-btn:hover, #new-setup-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: #fff;
  }
  .win-buttons { display: flex; gap: 14px; margin-top: 27px; }
</style>
</head>
<body>

<div id="game-container">
  <canvas id="game"></canvas>

  <!-- SETUP SCREEN -->
  <div id="setup-screen">
    <div class="setup-title">BLAST BELT</div>
    <div class="setup-sub">ROYALE</div>

    <div class="mode-selector">
      <button class="mode-btn active" data-mode="ffa" onclick="setMode('ffa')">FREE FOR ALL</button>
      <button class="mode-btn" data-mode="teams" onclick="setMode('teams')">TEAM BATTLE</button>
    </div>

    <div class="teams-area hidden" id="teams-area"></div>

    <div class="roster-label" id="roster-label">TAP TO SELECT FIGHTERS</div>
    <div class="roster-grid" id="roster-grid"></div>

    <div class="setup-settings">
      <button class="ss-toggle" data-key="weapons" onclick="toggleSetup(this)">WEAPONS</button>
      <button class="ss-toggle" data-key="passives" onclick="toggleSetup(this)">PASSIVES</button>
      <button class="ss-toggle" data-key="maneuvers" onclick="toggleSetup(this)">MANEUVERS</button>
      <button class="ss-toggle" data-key="randomLoadouts" onclick="toggleSetup(this)">RANDOM</button>
      <button class="ss-toggle" data-key="uniqueShips" onclick="toggleSetup(this)">UNIQUE SHIPS</button>
    </div>
    <div class="hp-row" id="hp-row"></div>

    <div class="setup-bottom">
      <button id="auto-fill-btn" onclick="autoFill()">ðŸŽ² RANDOM</button>
      <button id="start-match-btn" disabled onclick="launchMatch()">SELECT SHIPS</button>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown-overlay" class="hidden">
    <div id="cd-choose" style="font-family:'Orbitron',sans-serif; font-size:clamp(10px,2.5vw,16px); color:rgba(255,255,255,0.35); letter-spacing:6px; margin-bottom:4px; display:none;">CHOOSE YOUR TEAM!</div>
    <div class="cd-title" id="cd-title">Choose Your Fighter!</div>
    <div class="cd-fighters" id="cd-fighters"></div>
    <div class="cd-bottom">
      <div id="cd-timer">Battle Royale begins in: 3...</div>
      <div id="cd-bets" style="font-family:'Orbitron',sans-serif; font-size:clamp(10px,2.5vw,16px); color:rgba(255,255,255,0.35); letter-spacing:6px; margin-top:6px; display:none;">PLACE YOUR BETS!</div>
    </div>
  </div>

  <!-- MATCH HUD -->
  <div id="match-hud">
    <div class="hud-team top" id="hud-team1"></div>
    <div class="hud-team bottom" id="hud-team2"></div>
  </div>
  <div id="killfeed"></div>
  <div id="match-timer"></div>

  <!-- WINNER -->
  <div id="winner-overlay">
    <div id="winner-label">WINNER</div>
    <div id="winner-name"></div>
    <div id="rankings"></div>
    <div class="win-buttons">
      <button id="rematch-btn" onclick="rematch()">REMATCH</button>
      <button id="new-setup-btn" onclick="newSetup()">NEW MATCH</button>
    </div>
  </div>
</div>

<script>
// â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CFG = {
  WORLD_W: 2400,
  WORLD_H: 4200,
  NUM_SHIPS: 2,
  NUM_ASTEROIDS: 40,
  SHIP_RADIUS: 12,
  SHIP_THRUST: 192,
  SHIP_MAX_SPEED: 240,
  SHIP_TURN_SPEED: 5,
  BULLET_SPEED: 400,
  BULLET_LIFE: 1.8,
  FIRE_RATE: 0.28,
  ASTEROID_SPEED_MIN: 15,
  ASTEROID_SPEED_MAX: 70,
  ASTEROID_SIZES: [200, 50, 30, 16],
  RESPAWN_ASTEROIDS: true,
  INVULN_TIME: 0,
  SHIP_HP: 1,
  AI_REACTION: 0.05,
  CAMERA_LERP: 0.06,
};

// â”€â”€â”€ UTILITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function lerp(a, b, t) { return a + (b - a) * t; }
function shortAngleDist(a, b) {
  let d = ((b - a) % (Math.PI * 2) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
  return d;
}
function randomBehavior() {
  const b = ['aggressive','hunter','evasive','cautious','bloodthirsty'];
  return b[randInt(0, b.length - 1)];
}
function wrap(v, max) { return ((v % max) + max) % max; }
function bounceBullet(b, nx, ny, noFx) {
  const dot = b.vx * nx + b.vy * ny;
  b.vx -= 2 * dot * nx;
  b.vy -= 2 * dot * ny;
  b.x += nx * 6;
  b.y += ny * 6;
  b._bounceTime = gameTime;
  if (!noFx) spawnExplosion(b.x, b.y, b.color, 4, 40);
}
function detonateMine(mine) {
  for (let i = 0; i < 12; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, 80);
    particles.push({ x: mine.x, y: mine.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: rand(0.3, 1.2), maxLife: 1.2, color: mine.color, size: rand(1, 3) });
  }
  playAsteroidBreak();
  for (let i = 0; i < 16; i++) {
    const a = (i / 16) * Math.PI * 2;
    bullets.push({
      x: mine.x, y: mine.y, vx: Math.cos(a) * 500, vy: Math.sin(a) * 500,
      life: 0.4, owner: mine.ownerId, color: mine.color, damage: 2, type: 'grenade',
      size: 2, isShrapnel: true, contactDetonate: false, detonateTime: null,
      armed: true, armTime: 0, fireAng: a, spawnTime: gameTime,
      curveRate: 0, sineAmp: 0, sineFreq: 0,
    });
  }
  const repulsorRadius = 240, repulsorForce = 200;
  for (const ast of asteroids) {
    const d = dist(mine, ast);
    if (d < repulsorRadius && d > 0) {
      const pushAng = Math.atan2(ast.y - mine.y, ast.x - mine.x);
      const strength = 1 - (d / repulsorRadius);
      ast.vx += Math.cos(pushAng) * repulsorForce * strength;
      ast.vy += Math.sin(pushAng) * repulsorForce * strength;
    }
  }
  for (const ob of bullets) {
    if (ob.owner === mine.ownerId || ob.isShrapnel) continue;
    const d = dist(mine, ob);
    if (d < repulsorRadius && d > 0) {
      const pushAng = Math.atan2(ob.y - mine.y, ob.x - mine.x);
      const strength = 1 - (d / repulsorRadius);
      ob.vx += Math.cos(pushAng) * repulsorForce * strength;
      ob.vy += Math.sin(pushAng) * repulsorForce * strength;
    }
  }
  shockwaves.push({ x: mine.x, y: mine.y, r: 0, maxR: 240, life: 0.35, color: mine.color });
}
function updateCameraModeUI() {} // no-op in versus mode

// â”€â”€â”€ NAMES & COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€ SHIP SHAPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SHIP_SHAPES = [
  // RED
  [[-.1,-.15],[-.45,-.4],[-.2,-.4],[0,-.5],[-.2,-.65],[-.7,-.65],[-.7,-.4],[-.4,0],[-.75,.4],[-.75,.6],[-.5,.6],[-.2,.6],[0,.5],[-.2,.4],[-.45,.4],[-.1,.15],[.45,.2],[.6,.15],[.65,.1],[.75,.1],[.925,0],[.75,-.1],[.65,-.1],[.6,-.15],[.45,-.2]],
  // GREEN
  [[-1,0],[-.7,-.1],[-.75,-.4],[-.4,-.85],[-.25,-.7],[-.3,-.15],[0,-.5],[.3,-.25],[.2,0],[.5,-.15],[1,0],[.2,.45],[-.15,.25],[-.25,.65],[-.4,.8],[-.7,.45],[-.7,.1]],
  // BLUE
  [[1,0],[.75,-.2],[-.15,-1],[-.05,-.4],[-.35,-.25],[-.55,0],[-.35,.25],[-.05,.45],[-.15,1],[.75,.2]],
  // ORANGE
  [[1,0],[-.8,-.7],[-.65,-.2],[.1,0],[-.65,.2],[-.8,.7]],
  // PINK
  [[-.7,-.65],[-.5,-.75],[.15,-.55],[1,0],[.15,.55],[-.5,.75],[-.7,.65],[-.75,.35],[-.5,.1],[-.35,0],[-.5,-.1],[-.75,-.4]],
  // CYAN
  [[-.15,-.65],[-.8,-.65],[-.4,0],[-.8,.65],[-.2,.6],[-.45,.4],[1,0],[-.45,-.45]],
  // LIME
  [[.7,-.55],[.3,-1],[-.75,-.7],[-.85,-.2],[-.5,0],[-.85,.25],[-.7,.75],[.4,.95],[.65,.55],[.25,.7],[-.35,.5],[.2,.3],[1.1,0],[.2,-.25],[-.35,-.55],[.2,-.7]],
  // CORAL
  [[.55,-.25],[.1,-.65],[.1,-.2],[-.65,-.9],[-.45,-.1],[-1,0],[-.45,.15],[-.65,.9],[.1,.15],[.1,.6],[.55,.2],[.6,.5],[1,0],[.6,-.6]],
  // PURPLE
  [[-.75,-.8],[.1,-.5],[-.85,-.2],[.2,0],[-.85,.25],[.1,.55],[-.75,.8],[.1,.75],[.6,.3],[1,0],[.6,-.3],[.1,-.7]],
  // WHITE
  [[1,0],[-.7,-.65],[-.4,0],[-.7,.65]],
  // YELLOW
  [[1.2,0],[-.4,-.55],[-.6,-.45],[-.7,-.65],[-.2,-.2],[-.2,-.1],[-.85,0],[-.25,.05],[-.25,.2],[-.55,.4],[-.45,.65],[-.7,.65],[0,.3],[.15,-.05],[.25,.2],[.55,-.05],[.75,.25],[.85,.05]],
  // MAGENTA
  [[.95,0],[-.9,-.7],[-.5,0],[-.9,.65],[.05,.3],[-.4,-.3],[.3,.15],[.15,-.2],[.6,.1]],
  // SKY
  [[.25,-.15],[.5,-.25],[1,0],[.5,.25],[.25,.15],[0,.25],[.2,.45],[.35,.75],[.1,.95],[-.5,.95],[0,.7],[-.25,.6],[-.1,.5],[-.4,.25],[-.6,.25],[-1.05,.35],[-1,0],[-1.05,-.4],[-.6,-.25],[-.4,-.25],[-.25,-.35],[-.05,-.5],[-.25,-.6],[0,-.7],[-.5,-.95],[.1,-.95],[.35,-.75],[.2,-.45],[0,-.25]],
  // GOLD
  [[.99,0],[-.5,.85],[-.69,.55],[-.5,.35],[-.79,.4],[-.99,0],[-.79,-.4],[-.45,-.3],[-.69,-.55],[-.5,-.84]],
  // SILVER
  [[.85,-.5],[.75,-.65],[.5,-.85],[.25,-.95],[0,-1],[-.25,-.95],[-.5,-.85],[-.75,-.65],[-.85,-.5],[-1,0],[-.85,.5],[-.65,.75],[-.25,.95],[0,1],[.25,.95],[.55,.85],[.85,.55],[-.25,.65],[-.2,.25],[-.3,.1],[.25,0],[-.3,-.1],[-.2,-.25],[-.25,-.6]],
  // VIOLET
  [[.35,-.3],[.3,-.5],[-.25,-.95],[-.5,-.85],[-.1,-.3],[-.3,-.2],[-1,-.35],[-.8,-.1],[-.1,0],[-.1,0],[-.8,.1],[-1,.35],[-.3,.2],[-.1,.3],[-.5,.85],[-.25,.95],[.3,.5],[.35,.3],[.95,.2],[1.05,0],[.95,-.2]],
];

const CHEVRON_ID = 9; // White's classic chevron shape

function createShipIcon(shipId, color, size) {
  const effectiveId = setupSettings.uniqueShips ? shipId : CHEVRON_ID;
  const dpr = window.devicePixelRatio || 1;
  const c = document.createElement('canvas');
  c.width = size * dpr;
  c.height = size * dpr;
  c.style.width = size + 'px';
  c.style.height = size + 'px';
  c.className = 'ship-icon';
  const ctx = c.getContext('2d');
  ctx.scale(dpr, dpr);
  const verts = SHIP_SHAPES[effectiveId] || SHIP_SHAPES[CHEVRON_ID];
  const r = size * 0.38;
  ctx.save();
  ctx.translate(size / 2, size / 2);
  ctx.shadowColor = color;
  ctx.shadowBlur = size * 0.2;
  ctx.strokeStyle = color;
  ctx.lineWidth = Math.max(1, size * 0.08);
  ctx.fillStyle = color + '33';
  ctx.beginPath();
  ctx.moveTo(verts[0][0] * r, verts[0][1] * r);
  for (let i = 1; i < verts.length; i++) {
    ctx.lineTo(verts[i][0] * r, verts[i][1] * r);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  return c;
}

// â”€â”€â”€ NAMES & COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PILOT_NAMES = [
  'RED', 'GREEN', 'BLUE', 'ORANGE',
  'PINK', 'CYAN', 'LIME', 'CORAL',
  'PURPLE', 'WHITE', 'YELLOW', 'MAGENTA',
  'SKY', 'GOLD', 'SILVER', 'VIOLET'
];
const PILOT_COLORS = [
  '#ff4444', '#44ff88', '#4488ff', '#ffaa22',
  '#dd66bb', '#44ffff', '#88dd55', '#ff6b4a',
  '#aa44ff', '#ffffff', '#ffff44', '#ff00ff',
  '#55bbff', '#ffcc00', '#bbbbcc', '#8844dd'
];

// â”€â”€â”€ PREDETERMINED PERSONALITY PROFILES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PRESET_PROFILES = [
  // RED:     Reckless berserker â€” charges in, sprays lead, blasts everything
  { behavior: 'aggressive', aggroSpeed: 0.18, aggroPhase: 0,     aimBaseline: 0.4, aimRange: 0.45, aimSpeed: 0.7, aimPhase: 0,    rockShooter: 0.85 },
  // GREEN:   Calculated sniper â€” patient lead shots, avoids rocks cleanly
  { behavior: 'hunter',     aggroSpeed: 0.25, aggroPhase: 1.2,   aimBaseline: 0.85, aimRange: 0.3, aimSpeed: 0.35, aimPhase: 1.0, rockShooter: 0.2 },
  // BLUE:    Steady soldier â€” balanced everything, reliable mid-range
  { behavior: 'hunter',     aggroSpeed: 0.3,  aggroPhase: 2.5,   aimBaseline: 0.65, aimRange: 0.35, aimSpeed: 0.5, aimPhase: 2.0, rockShooter: 0.5 },
  // ORANGE:  Hot-headed brawler â€” aggressive with wild aim, loves explosions
  { behavior: 'aggressive', aggroSpeed: 0.35, aggroPhase: 0.8,   aimBaseline: 0.35, aimRange: 0.5, aimSpeed: 0.75, aimPhase: 3.1, rockShooter: 0.9 },
  // PINK:    Elusive dancer â€” dodges everything, precise when they do shoot
  { behavior: 'evasive',    aggroSpeed: 0.2,  aggroPhase: 4.0,   aimBaseline: 0.9, aimRange: 0.3, aimSpeed: 0.4, aimPhase: 0.5,  rockShooter: 0.15 },
  // CYAN:    Cool tactician â€” cautious approach, strong lead prediction
  { behavior: 'cautious',   aggroSpeed: 0.22, aggroPhase: 3.2,   aimBaseline: 0.8, aimRange: 0.35, aimSpeed: 0.45, aimPhase: 4.2, rockShooter: 0.35 },
  // LIME:    Twitchy scrapper â€” fast aggression cycles, chaotic aim
  { behavior: 'hunter',     aggroSpeed: 0.4,  aggroPhase: 5.5,   aimBaseline: 0.5, aimRange: 0.5, aimSpeed: 0.8, aimPhase: 1.8,  rockShooter: 0.7 },
  // CORAL:   Bloodthirsty bruiser â€” ignores asteroids when locked onto a target
  { behavior: 'bloodthirsty', aggroSpeed: 0.25, aggroPhase: 1.0,   aimBaseline: 0.15, aimRange: 0.35, aimSpeed: 0.3, aimPhase: 5.0,  rockShooter: 0.6 },
  // PURPLE:  Ghost â€” evasive navigator, rarely shoots rocks, precise aim
  { behavior: 'evasive',    aggroSpeed: 0.28, aggroPhase: 2.0,   aimBaseline: 0.75, aimRange: 0.4, aimSpeed: 0.5, aimPhase: 3.5, rockShooter: 0.1 },
  // WHITE:   Wildcard â€” cautious but with dramatic aggro swings
  { behavior: 'cautious',   aggroSpeed: 0.38, aggroPhase: 4.8,   aimBaseline: 0.6, aimRange: 0.45, aimSpeed: 0.6, aimPhase: 0.3, rockShooter: 0.45 },
  // YELLOW:  Bombardier â€” hunts aggressively, blasts everything in sight
  { behavior: 'hunter',     aggroSpeed: 0.32, aggroPhase: 0.5,   aimBaseline: 0.7, aimRange: 0.4, aimSpeed: 0.55, aimPhase: 2.8, rockShooter: 0.8 },
  // MAGENTA: Razor â€” cautious with lethal precision, never wastes a shot
  { behavior: 'cautious',   aggroSpeed: 0.2,  aggroPhase: 3.8,   aimBaseline: 0.95, aimRange: 0.3, aimSpeed: 0.35, aimPhase: 4.5, rockShooter: 0.25 },
  // SKY:     Acrobat â€” evasive, avoids shooting rocks, icy precision
  { behavior: 'evasive',    aggroSpeed: 0.3,  aggroPhase: 5.0,   aimBaseline: 0.7, aimRange: 0.4, aimSpeed: 0.6, aimPhase: 1.5,  rockShooter: 0.05 },
  // GOLD:    Guardian â€” extremely protective, avoids ships and asteroids
  { behavior: 'evasive',    aggroSpeed: 0.15, aggroPhase: 2.2,   aimBaseline: 0.6, aimRange: 0.35, aimSpeed: 0.45, aimPhase: 3.0, rockShooter: 0.95 },
  // SILVER:  Everyman â€” middle of the road on everything
  { behavior: 'hunter',     aggroSpeed: 0.28, aggroPhase: 1.8,   aimBaseline: 0.6, aimRange: 0.35, aimSpeed: 0.5, aimPhase: 2.5, rockShooter: 0.5 },
  // VIOLET:  Aggressive toward ships, less interested in asteroids, area denial
  { behavior: 'aggressive', aggroSpeed: 0.32, aggroPhase: 4.2,   aimBaseline: 0.55, aimRange: 0.4, aimSpeed: 0.55, aimPhase: 1.2, rockShooter: 0.3 },
];

// â”€â”€â”€ WEAPON DEFINITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WEAPON_DEFS = {
  basic:        { name:'Standard Issue',    speed:400, life:2.0, fireRate:0.28, damage:3, type:'basic' },
  shotgun:      { name:'Shotgun',        speed:460, life:1.5, fireRate:1.0,  damage:1, type:'shotgun',    pellets:5, spread:14 },
  grenade:      { name:'Grenade',        speed:400, life:1.3, fireRate:2.0,  damage:2, type:'grenade',    fuseTime:0.65, shrapCount:16, shrapDmg:2, shrapLife:0.4, shrapSpeed:300 },
  triple:       { name:'Triple-guns',    speed:400, life:1.8, fireRate:0.6,  damage:2, type:'triple',     burstCount:3, burstDelay:0.05 },
  homing:       { name:'Homing Missiles',speed:300, life:2.4, fireRate:4.0,  damage:2, type:'homing',     launchSpeed:50, boostDelay:0.15 },
  alternating:  { name:'Twin Blasters',  speed:400, life:1.65, fireRate:0.28, damage:2, type:'alternating', offset:6 },
  flamethrower: { name:'Dragonfire',    speed:250, life:2.0, fireRate:2.5,  damage:1, type:'flamethrower',burstCount:30, amplitude:15 },
  sniper:       { name:'Sniper',         speed:780, life:2.0, fireRate:1.05, damage:5, type:'sniper' },
  chaotic:      { name:'Chaotic Shot',   speed:400, life:1.8, fireRate:0.28, damage:3, type:'chaotic' },
  scrap:        { name:'Scrap Shot',     speed:400, life:1.75, fireRate:1.0,  damage:2, type:'scrap',      fuseTime:0.4, shrapCount:5, shrapSpread:20, shrapSpeed:400 },
  snake:        { name:'Snake Shot',     speed:400, life:1.8, fireRate:0.4,  damage:3, type:'snake' },
  gatling:      { name:'Gatling Gun',    speed:720, life:1.8, fireRate:2.6,  damage:1, type:'gatling',    burstCount:15, burstDelay:0.08, spread:4 },
  boomerang:    { name:'Boomerang', speed:350, life:1.8, fireRate:0.35, damage:3, type:'boomerang' },
  doublehelix:  { name:'Double Helix',  speed:450, life:2.2, fireRate:0.64, damage:2.2, type:'doublehelix', offset:4 },
  cyclone:      { name:'Cyclone Shot',  speed:480, life:2.4, fireRate:2.0,  damage:0.8, type:'cyclone',    projectiles:5, innerProjectiles:2 },
  crossshot:    { name:'Cross-Shot',    speed:540, life:1.05, fireRate:0.4, damage:1.5, type:'crossshot',  offset:12, convergeDist:250 },
  lightning:    { name:'Lightning Bolt', speed:1600, life:0.34, fireRate:0.77, damage:3, type:'lightning' },
  concussive:   { name:'Scatterburst',    speed:400, life:1.5, fireRate:0.374, damage:3, type:'concussive', splitCount:4, splitDmg:2, splitLife:0.2, splitSpeed:300 },
  drone:        { name:'Drone Array',     speed:350, life:6.0, fireRate:2.5,   damage:1.5, type:'drone', droneCount:6, armTime:3.0, launchInterval:0.5, orbitSpeed:100, turnRate:0.75 },
};

// Ship index â†’ weapon key mapping
// RED=alternating, GREEN=chaotic, BLUE=grenade, ORANGE=flamethrower,
// PINK=gatling, CYAN=homing, LIME=snake, CORAL=shotgun,
// PURPLE=scrap, WHITE=basic, YELLOW=lightning, MAGENTA=sniper
const SHIP_WEAPONS = ['alternating','chaotic','grenade','flamethrower','gatling','homing','snake','shotgun','scrap','basic','lightning','sniper','cyclone','drone','crossshot','concussive'];

const WEAPON_KEYS = Object.keys(WEAPON_DEFS);

function getWeapon(shipIdx, teamNum) {
  // Per-team weapon pool (team indices are 1-based, teamWeapons is 0-based)
  if (teamNum > 0 && teamWeapons[teamNum - 1] && teamWeapons[teamNum - 1].length > 0) {
    const pool = teamWeapons[teamNum - 1];
    const key = pool[randInt(0, pool.length - 1)];
    return {...WEAPON_DEFS[key]};
  }
  if (!settings.weapons) return {...WEAPON_DEFS.basic};
  if (settings.randomWeapons) {
    const key = WEAPON_KEYS[randInt(0, WEAPON_KEYS.length - 1)];
    return {...WEAPON_DEFS[key]};
  }
  return {...WEAPON_DEFS[SHIP_WEAPONS[shipIdx]]};
}

// â”€â”€â”€ PASSIVE ABILITIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PASSIVE_DEFS = {
  none:        { name: 'None',         desc: '' },
  scrapRepair: { name: 'Scrap Armor', desc: '+1.5 HP on kill (can overheal)' },
  bioHull:     { name: 'Bio-Hull',     desc: '+1 HP, regen 0.1/2s, -10% accel' },
  nitro:       { name: 'Nitro',        desc: '+30% accel, +40% top speed' },
  gyro:        { name: 'Gyro',         desc: '+30% turn speed' },
  shield:      { name: 'Shield',       desc: 'Ignore first hit' },
  piercing:    { name: 'Piercing',     desc: 'Shots pierce targets' },
  fierce:      { name: 'Fierce',       desc: '+35% damage' },
  hitInvuln:   { name: 'Phase-Out',   desc: '2s invuln on hit, clears debuffs' },
  scope:       { name: 'Scope',        desc: '+20% weapon range' },
  titanium:    { name: 'Titanium',     desc: '-25% incoming damage' },
  stealth:     { name: 'Stealth',      desc: 'Perceived as 1.5x distance' },
  sparkDrive:  { name: 'Spark Drive',  desc: '+20% projectile speed' },
  drillbore:   { name: 'Drillbore',    desc: 'Survives collisions (10% chip dmg)' },
  iceRounds:   { name: 'Ice Rounds',   desc: 'Slows + 0.25 HP DoT' },
  jamRounds:   { name: 'Jam Rounds',   desc: 'Jams hit targets\' fire rate' },
  incendiary:  { name: 'Incendiary',   desc: '50% damage as burn DoT, trail dmg' },
  obliterator: { name: 'Obliterator',  desc: 'Asteroids explode on hit' },
  absorber:    { name: 'Absorber',     desc: 'Bullets delete nearby enemy projectiles' },
  detonator:   { name: 'Detonator',    desc: 'Kill triggers explosion' },
  stunShock:   { name: 'Stun Shock',   desc: 'Hits freeze target turning' },
  override:    { name: 'Override',     desc: 'Hits hijack target controls' },
  cryoCoolant: { name: 'Fast Cycling', desc: '-20% fire cooldown' },
  flagship:    { name: 'Flagship',     desc: '+7 HP, 2.5x size, survives collisions, no maneuvers' },
  blindRounds: { name: 'Blinding Rounds', desc: 'Hits blind enemy detection for 6s' },
  bouncyShot:  { name: 'Bouncy Shot',    desc: 'Bullets ricochet off ships, rocks, and projectiles' },
};
const PASSIVE_KEYS = Object.keys(PASSIVE_DEFS).filter(k => k !== 'none');

// Ship index â†’ passive key mapping
// RED=nitro, GREEN=bouncyShot, BLUE=obliterator, ORANGE=incendiary,
// PINK=sparkDrive, CYAN=shield, LIME=absorber, CORAL=drillbore,
// PURPLE=stealth, WHITE=hitInvuln, YELLOW=stunShock, MAGENTA=scope
const SHIP_PASSIVES = ['nitro','bouncyShot','stealth','incendiary','sparkDrive','shield','absorber','drillbore','obliterator','hitInvuln','stunShock','scope','iceRounds','flagship','gyro','override'];

// Passives that are useless in one-hit-kill (no unique weapons) matches
const ONESHOT_USELESS_PASSIVES = ['hitInvuln'];

function getPassive(shipIdx, teamNum) {
  // Per-team passive pool
  if (teamNum > 0 && teamPassives[teamNum - 1] && teamPassives[teamNum - 1].length > 0) {
    const pool = teamPassives[teamNum - 1];
    return pool[randInt(0, pool.length - 1)];
  }
  const pool = (!settings.weapons)
    ? PASSIVE_KEYS.filter(k => !ONESHOT_USELESS_PASSIVES.includes(k))
    : PASSIVE_KEYS;
  // Chaos mode always randomizes
  if (settings.chaosMode) {
    return pool[randInt(0, pool.length - 1)];
  }
  // Passives disabled â†’ none
  if (!settings.passives) return 'none';
  // Random weapons â†’ random passives too
  if (settings.randomWeapons) {
    return pool[randInt(0, pool.length - 1)];
  }
  // Unique passives from preset map
  if (shipIdx != null) {
    return SHIP_PASSIVES[shipIdx] || 'none';
  }
  return 'none';
}

// â”€â”€â”€ MANEUVER ABILITIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MANEUVER_DEFS = {
  hyperSpeed: {
    name: 'Hyper-Speed', desc: '3x speed burst for 0.75s',
    cooldown: 5, duration: 0.375,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.06, attacking: 0.025, debuffed: 0.05 },
  },
  barrelRoll: {
    name: 'Barrel Roll', desc: 'Fast loop, +30% fire rate during',
    cooldown: 3, duration: 0.25,
    triggers: { random: 0.01, underFire: 0.06, damaged: 0.04, attacking: 0.025, debuffed: 0.05 },
  },
  quickTurn: {
    name: 'Quick-Turn', desc: 'Boomerang arc into new direction with momentum',
    cooldown: 4, duration: 0.5,
    triggers: { random: 0.005, underFire: 0.06, damaged: 0.075, debuffed: 0.06 },
  },
  turretMode: {
    name: 'Turret Mode', desc: 'Stop and fire at 2x rate, +accuracy',
    cooldown: 4, duration: 1.5,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.03, attacking: 0.04 },
  },
  serpentine: {
    name: 'Serpentine', desc: '3x speed strafing, 3 sweeps',
    cooldown: 4, duration: 0.45,
    triggers: { random: 0.015, underFire: 0.05, damaged: 0.04, attacking: 0.02, debuffed: 0.04 },
  },
  panic: {
    name: 'Panic', desc: 'Wild spin with 3x fire rate',
    cooldown: 5, duration: 0.4,
    triggers: { random: 0.0, underFire: 0.06, damaged: 0.09, debuffed: 0.07 },
  },
  rapidFire: {
    name: 'Rapid Fire', desc: '2x fire rate for 1s, reduced accuracy',
    cooldown: 6, duration: 0.5,
    triggers: { random: 0.01, underFire: 0.02, damaged: 0.01, attacking: 0.06 },
  },
  spinOut: {
    name: 'Spin Out', desc: 'Boomerang arc into accuracy+speed boost',
    cooldown: 5, duration: 0.8,
    triggers: { random: 0.01, underFire: 0.05, damaged: 0.06, attacking: 0.04, debuffed: 0.05 },
    afterDuration: 1.0, // bonus lasts after maneuver ends
  },
  reverse: {
    name: 'Reverse', desc: 'Fly backwards while firing',
    cooldown: 5, duration: 0.6,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.03, attacking: 0.04 },
  },
  smokescreen: {
    name: 'Smokescreen', desc: 'Particle cloud + near-invisibility',
    cooldown: 10, duration: 2.5,
    triggers: { random: 0.0, underFire: 0.04, damaged: 0.06, debuffed: 0.05 },
  },
  doubleTeam: {
    name: 'Double Team', desc: '4 orbiting decoy clones block projectiles',
    cooldown: 10, duration: 8.0,
    triggers: { random: 0.01, underFire: 0.04, damaged: 0.05, attacking: 0.02, debuffed: 0.04 },
  },
  dumpDebris: {
    name: 'Dump Debris', desc: 'Drop projectile-absorbing debris cloud',
    cooldown: 6, duration: 0.05,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, debuffed: 0.05 },
    minSpeedPct: 0.3,
  },
  reflectorShields: {
    name: 'Reflector Shields', desc: 'Orbiting shields reflect projectiles',
    cooldown: 10, duration: 4.5,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, debuffed: 0.05 },
  },
  repulsor: {
    name: 'Repulsor', desc: 'Shockwave erases projectiles, blasts particles',
    cooldown: 8, duration: 0.05,
    triggers: { random: 0.01, underFire: 0.04, damaged: 0.05, attacking: 0.02, debuffed: 0.04 },
  },
  shockPulse: {
    name: 'Shock Pulse', desc: 'Massive stun shockwave hits nearby ships',
    cooldown: 10, duration: 0.05,
    triggers: { random: 0.0, underFire: 0.05, damaged: 0.06, attacking: 0.03 },
  },
  mineField: {
    name: 'Mine Field', desc: 'Drop 3 proximity mines',
    cooldown: 15, duration: 1.25,
    triggers: { random: 0.02, underFire: 0.04, damaged: 0.05 },
    minGameTime: 4, // not usable in first 8 seconds
  },
};
const MANEUVER_KEYS = Object.keys(MANEUVER_DEFS);

// RED=rapidFire, GREEN=reverse, BLUE=mineField, ORANGE=smokescreen,
// PINK=doubleTeam, CYAN=barrelRoll, LIME=repulsor, CORAL=hyperSpeed,
// PURPLE=dumpDebris, WHITE=reflectorShields, YELLOW=shockPulse, MAGENTA=turretMode
const SHIP_MANEUVERS = ['rapidFire','reverse','mineField','smokescreen','doubleTeam','barrelRoll','repulsor','hyperSpeed','dumpDebris','reflectorShields','shockPulse','turretMode','spinOut','repulsor','panic','quickTurn'];

function getManeuver(shipIdx, teamNum) {
  // Per-team maneuver pool
  if (teamNum > 0 && teamManeuvers[teamNum - 1] && teamManeuvers[teamNum - 1].length > 0) {
    const pool = teamManeuvers[teamNum - 1];
    return pool[randInt(0, pool.length - 1)];
  }
  if (!settings.maneuvers) return 'none';
  // Chaos mode always randomizes
  if (settings.chaosMode) {
    return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  // Random weapons â†’ random maneuvers too
  if (settings.randomWeapons) {
    return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  // Preset assignment
  if (shipIdx != null) {
    return SHIP_MANEUVERS[shipIdx] || MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
  }
  return MANEUVER_KEYS[randInt(0, MANEUVER_KEYS.length - 1)];
}

// Check if a maneuver should trigger this AI tick
function checkManeuverTrigger(ship) {
  if (ship.maneuver === 'none' || ship.maneuverCooldown > 0 || ship.maneuverActive) return false;
  const def = MANEUVER_DEFS[ship.maneuver];
  if (!def) return false;

  // Determine active contexts
  const recentlyDamaged = ship.lastAttacker >= 0 && (gameTime - ship.lastAttackerTime) < 1;
  const underFire = !!ship._bulletThreat;
  const attacking = !!ship._aiShoot;
  const debuffed = ship.iceSlow > 0 || ship.jamSlow > 0 || ship.stunTimer > 0 || ship.overrideTimer > 0 || ship.blindTimer > 0;

  // Incoming homing missile â€” always trigger if off cooldown (except turret mode)
  if (ship.maneuver !== 'turretMode') {
    for (const b of bullets) {
      if (b.type === 'homing' && !b.isShrapnel && b.owner !== ship.id) {
        const d = dist(ship, b);
        if (d < 300) return true;
      }
    }
  }

  // Accumulate trigger chance from all active contexts
  let chance = def.triggers.random || 0;
  if (underFire) chance = Math.max(chance, def.triggers.underFire || 0);
  if (recentlyDamaged) chance = Math.max(chance, def.triggers.damaged || 0);
  if (attacking) chance = Math.max(chance, def.triggers.attacking || 0);
  if (debuffed) chance = Math.max(chance, def.triggers.debuffed || 0);

  // Minimum speed requirement (e.g. Dump Debris)
  if (def.minSpeedPct) {
    const spd = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    const maxSpd = CFG.SHIP_MAX_SPEED * (ship.passive === 'nitro' ? 1.4 : 1);
    if (spd < maxSpd * def.minSpeedPct) return false;
  }

  // Minimum game time requirement (e.g. Mine Field)
  if (def.minGameTime && gameTime < def.minGameTime) return false;

  return Math.random() < chance;
}

// Activate a maneuver
function startManeuver(ship) {
  const def = MANEUVER_DEFS[ship.maneuver];
  if (!def) return;
  ship.maneuverActive = true;
  ship.maneuverTimer = def.duration;
  ship.maneuverCooldown = def.cooldown;
  // Double Team: cooldown starts after duration ends, not at activation
  if (ship.maneuver === 'doubleTeam') ship.maneuverCooldown = 0;

  if (ship.maneuver === 'hyperSpeed') {
    // Moderate initial kick in current facing direction (ramps up each frame)
    const curSpeed = Math.hypot(ship.vx, ship.vy);
    const kickSpeed = Math.max(curSpeed, CFG.SHIP_MAX_SPEED * 1.5);
    ship.vx = Math.cos(ship.ang) * kickSpeed;
    ship.vy = Math.sin(ship.ang) * kickSpeed;
    // Visual: shockwave + bright trail burst
    spawnExplosion(ship.x, ship.y, ship.color, 10, 60);
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 40, life: 0.3, color: ship.color });
  }

  if (ship.maneuver === 'teleport') {
    // Phase 1: charging â€” ship visible, emitting shockwaves for 0.5s
    ship._teleportPhase = 'charging';
    // Pick a random dash direction
    ship._teleportAng = rand(0, Math.PI * 2);
    ship._teleportShockTimer = 0;
  }

  if (ship.maneuver === 'barrelRoll') {
    ship._rollDir = Math.random() < 0.5 ? 1 : -1;
    // Boost speed slightly
    const boostSpeed = CFG.SHIP_MAX_SPEED * 1.5;
    const curSpeed = Math.hypot(ship.vx, ship.vy);
    if (curSpeed < boostSpeed) {
      ship.vx = Math.cos(ship.ang) * boostSpeed;
      ship.vy = Math.sin(ship.ang) * boostSpeed;
    }
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'quickTurn') {
    // Boomerang arc â€” pick target roughly 180Â° back with slight randomness
    const cAng = Math.atan2(ship.vy, ship.vx);
    ship._quickTurnTarget = cAng + Math.PI + rand(-0.4, 0.4);
    ship._quickTurnDone = false;
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'turretMode') {
    // Halt movement
    spawnExplosion(ship.x, ship.y, ship.color, 6, 30);
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 25, life: 0.3, color: ship.color });
  }

  if (ship.maneuver === 'serpentine') {
    ship._serpDir = Math.random() < 0.5 ? 1 : -1;
    ship._serpSweep = 0; // counts completed direction changes
    ship._serpTimer = 0;
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'panic') {
    // Random spin between 270-540 degrees
    const spinDeg = rand(270, 540);
    ship._panicSpinTotal = spinDeg * Math.PI / 180;
    ship._panicSpinDone = 0;
    ship._panicDir = Math.random() < 0.5 ? 1 : -1;
    spawnExplosion(ship.x, ship.y, ship.color, 8, 50);
  }

  if (ship.maneuver === 'rapidFire') {
    ship.fireCooldown = 0; // start shooting immediately
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'spinOut') {
    // Boomerang arc â€” pick target roughly 180Â° back with slight randomness
    const cAng = Math.atan2(ship.vy, ship.vx);
    ship._spinOutArcTarget = cAng + Math.PI + rand(-0.4, 0.4);
    ship._spinOutPhase = 'arc';
    ship._spinOutBoostTimer = 0;
    spawnExplosion(ship.x, ship.y, ship.color, 6, 40);
  }

  if (ship.maneuver === 'reverse') {
    // Phase 1: decel (0.2s), Phase 2: reverse thrust (1.0s)
    ship._reversePhase = 'decel';
    spawnExplosion(ship.x, ship.y, ship.color, 5, 30);
  }

  if (ship.maneuver === 'smokescreen') {
    // Emit a big cloud of grey particles puffing in all directions
    for (let i = 0; i < 50; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(60, 200);
      particles.push({
        x: ship.x + rand(-15, 15), y: ship.y + rand(-15, 15),
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
        life: rand(1.5, 3.0), maxLife: 3.0,
        color: '#888888', size: rand(3, 7),
      });
    }
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 80, life: 0.4, color: '#888888' });
    ship._smokestealthTimer = 5.0;
    smokeDecoys.push({ x: ship.x, y: ship.y, ownerId: ship.id, life: 2.0 });
  }

  if (ship.maneuver === 'doubleTeam') {
    // Spawn 4 clones: front, back, left, right â€” orbiting the ship
    const offsetDist = ship.r * 5;
    const dur = MANEUVER_DEFS.doubleTeam.duration;
    for (let ci = 0; ci < 4; ci++) {
      const orbitStart = (ci / 4) * Math.PI * 2; // 0, Ï€/2, Ï€, 3Ï€/2
      shipClones.push({
        ownerId: ship.id,
        shipId: ship.typeId,
        x: ship.x, y: ship.y,
        ang: ship.ang,
        r: ship.r,
        color: ship.color,
        orbitAngle: orbitStart,
        orbitRadiusBase: offsetDist,
        orbitDuration: dur, // used to calc expansion
        orbitElapsed: 0,
        life: dur + 1, // lives slightly longer than maneuver
        hit: false,
        hitTimer: 0,
        alive: true,
      });
    }
    spawnExplosion(ship.x, ship.y, ship.color, 10, 50);
  }

  if (ship.maneuver === 'dumpDebris') {
    // Spawn 120 debris squares behind the ship
    const backAng = ship.ang + Math.PI;
    for (let i = 0; i < 120; i++) {
      // Cone behind the ship, Â±60 degrees
      const a = backAng + rand(-1.05, 1.05);
      const sp = rand(30, 200);
      debrisField.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-20, 20),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-20, 20),
        vx: Math.cos(a) * sp + ship.vx * 0.3,
        vy: Math.sin(a) * sp + ship.vy * 0.3,
        size: rand(3, 7),
        life: rand(4.0, 8.0),
        color: ship.color,
        ownerId: ship.id,
      });
    }
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 80, life: 0.4, color: ship.color });
  }

  if (ship.maneuver === 'reflectorShields') {
    // Spawn 3 orbiting shield panels
    ship._reflectorAngle = 0;
    for (let i = 0; i < 3; i++) {
      reflectorShields.push({
        ownerId: ship.id,
        index: i,
        baseAngle: (Math.PI * 2 / 3) * i, // evenly spaced 120Â° apart
        orbitRadius: ship.r * 2.5,
        halfLength: ship.r * 0.9, // ~half ship length
        color: ship.color,
        life: 6.0,
      });
    }
    spawnExplosion(ship.x, ship.y, ship.color, 8, 40);
  }

  if (ship.maneuver === 'repulsor') {
    // Expanding shockwave that affects projectiles as it passes
    ship._repulsorX = ship.x;
    ship._repulsorY = ship.y;
    ship._repulsorLife = 0.5;    // matches shockwave maxLife
    ship._repulsorMaxLife = 0.5;
    ship._repulsorRadius = 350;  // matches shockwave maxR
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 350, life: 0.5, maxLife: 0.5, color: ship.color });
    spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
    playShootRise();
  }

  if (ship.maneuver === 'shockPulse') {
    // Massive stun pulse â€” 2x repulsor radius
    const pulseRadius = 700;
    shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: pulseRadius, life: 0.6, maxLife: 0.6, color: '#ffff44' });
    spawnExplosion(ship.x, ship.y, '#ffff44', 20, 120);
    playShootRise();
    // Stun all enemy ships in range
    let stunHit = false;
    for (const target of ships) {
      if (!target.alive || target.id === ship.id || target.invuln > 0) continue;
      if (ship.team > 0 && target.team === ship.team) continue;
      if (dist(ship, target) < pulseRadius) {
        target.stunTimer = 1.75;
        stunHit = true;
        // Stun arc sparks on affected ship
        for (let sp = 0; sp < 4; sp++) {
          const a = rand(0, Math.PI * 2);
          const arcLen = rand(10, 25);
          const segs = randInt(2, 3);
          const ap = [{x: 0, y: 0}];
          for (let s = 1; s <= segs; s++) {
            const t = s / segs;
            ap.push({
              x: Math.cos(a) * arcLen * t + rand(-5, 5),
              y: Math.sin(a) * arcLen * t + rand(-5, 5)
            });
          }
          particles.push({
            x: target.x + rand(-target.r, target.r),
            y: target.y + rand(-target.r, target.r),
            vx: Math.cos(a) * rand(40, 80), vy: Math.sin(a) * rand(40, 80),
            life: rand(0.15, 0.3), maxLife: 0.3,
            color: '#ffff44', size: 1.5,
            isArc: true, arcPoints: ap,
          });
        }
      }
    }
    if (stunHit) playDebuff();
  }

  if (ship.maneuver === 'mineField') {
    ship._minesDropped = 0;
    ship._mineDropTimer = 0; // drop first mine immediately
  }
}

// Process active maneuver each frame
function updateManeuver(ship, dt) {
  const _tl = ship.team > 0 ? 3 : 1; // team trail life multiplier
  if (!ship.maneuverActive) return;
  ship.maneuverTimer -= dt;

  if (ship.maneuver === 'hyperSpeed') {
    // Allow speed to exceed normal cap during maneuver (3x)
    ship._hyperSpeedActive = true;
    if (ship.maneuverTimer > 0.25) {
      // Accelerating phase: heavy thrust
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 8 * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 8 * dt;
    } else {
      // Decelerating phase: heavy drag to bleed speed
      const brakeFactor = 1 - 3.5 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
    }
    ship.thrustOn = true;
    // Spawn speed trail particles â€” center + two rear corners
    const backAng = ship.ang + Math.PI;
    const perpAng = ship.ang + Math.PI * 0.5;
    if (Math.random() < 0.7) {
      particles.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-8, 8),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-8, 8),
        vx: Math.cos(backAng) * rand(100, 200), vy: Math.sin(backAng) * rand(100, 200),
        life: rand(0.3, 0.6) * _tl, maxLife: 0.6 * _tl, color: trailColor(ship), size: rand(2, 5),
      });
    }
    // Left rear corner trail
    if (Math.random() < 0.6) {
      const cx = ship.x + Math.cos(backAng) * ship.r * 0.7 + Math.cos(perpAng) * ship.r * 0.6;
      const cy = ship.y + Math.sin(backAng) * ship.r * 0.7 + Math.sin(perpAng) * ship.r * 0.6;
      particles.push({
        x: cx + rand(-3, 3), y: cy + rand(-3, 3),
        vx: Math.cos(backAng) * rand(80, 160) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(80, 160) + rand(-15, 15),
        life: rand(0.25, 0.5) * _tl, maxLife: 0.5 * _tl, color: trailColor(ship), size: rand(1.5, 3.5),
      });
    }
    // Right rear corner trail
    if (Math.random() < 0.6) {
      const cx = ship.x + Math.cos(backAng) * ship.r * 0.7 - Math.cos(perpAng) * ship.r * 0.6;
      const cy = ship.y + Math.sin(backAng) * ship.r * 0.7 - Math.sin(perpAng) * ship.r * 0.6;
      particles.push({
        x: cx + rand(-3, 3), y: cy + rand(-3, 3),
        vx: Math.cos(backAng) * rand(80, 160) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(80, 160) + rand(-15, 15),
        life: rand(0.25, 0.5) * _tl, maxLife: 0.5 * _tl, color: trailColor(ship), size: rand(1.5, 3.5),
      });
    }
  }

  if (ship.maneuver === 'teleport') {
    const phaseDuration = 0.5; // phasing lasts 1s
    const chargeDuration = 0.25; // charging lasts 0.5s
    const phaseStart = phaseDuration; // timer value when phasing begins

    if (ship._teleportPhase === 'charging') {
      // Emit concentric shockwaves during charge-up
      ship._teleportShockTimer -= dt;
      if (ship._teleportShockTimer <= 0) {
        ship._teleportShockTimer = 0.05;
        shockwaves.push({
          x: ship.x, y: ship.y, r: 0,
          maxR: rand(25, 50), life: 0.3, maxLife: 0.3, color: ship.color,
        });
      }
      // Transition to phasing at 1.0s remaining
      if (ship.maneuverTimer <= phaseStart) {
        ship._teleportPhase = 'phasing';
        ship.invuln = phaseDuration + 0.15;
        spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
        shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 50, life: 0.4, color: ship.color });
        // Set initial dash velocity
        ship.vx = Math.cos(ship._teleportAng) * CFG.SHIP_MAX_SPEED * 1.7;
        ship.vy = Math.sin(ship._teleportAng) * CFG.SHIP_MAX_SPEED * 1.7;
      }
    }

    if (ship._teleportPhase === 'phasing') {
      // First half: accelerate. Second half: decelerate.
      const phaseElapsed = phaseStart - ship.maneuverTimer;
      const phaseT = phaseElapsed / phaseDuration; // 0â†’1
      if (phaseT < 0.5) {
        // Accelerate in dash direction
        ship.vx += Math.cos(ship._teleportAng) * CFG.SHIP_THRUST * 4 * dt;
        ship.vy += Math.sin(ship._teleportAng) * CFG.SHIP_THRUST * 4 * dt;
      } else {
        // Heavy drag to decelerate
        const brakeFactor = 1 - 4.0 * dt;
        ship.vx *= Math.max(0, brakeFactor);
        ship.vy *= Math.max(0, brakeFactor);
      }

      // Asteroid evasion while invisible â€” steer away from imminent collisions
      if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
        let evadeX = 0, evadeY = 0, evadeN = 0;
        for (const ast of asteroids) {
          const d = dist(ship, ast);
          if (d > ast.r + 400) continue;
          const col = predictCollision(ship, ast, 1.0);
          if (col) {
            const toAst = angle(ship, ast);
            const urgency = 1 / (col.t + 0.05);
            evadeX -= Math.cos(toAst) * urgency;
            evadeY -= Math.sin(toAst) * urgency;
            evadeN++;
          }
        }
        if (evadeN > 0) {
          const evadeAng = Math.atan2(evadeY, evadeX);
          ship.vx += Math.cos(evadeAng) * CFG.SHIP_THRUST * 3 * dt;
          ship.vy += Math.sin(evadeAng) * CFG.SHIP_THRUST * 3 * dt;
        }
      }

      // Faint particle trail (visible but subtle)
      if (Math.random() < 0.4) {
        particles.push({
          x: ship.x + rand(-5, 5), y: ship.y + rand(-5, 5),
          vx: rand(-20, 20), vy: rand(-20, 20),
          life: rand(0.3, 0.5) * _tl, maxLife: 0.5 * _tl,
          color: trailColor(ship), size: rand(1, 2.5),
        });
      }
    }
  }

  if (ship.maneuver === 'barrelRoll') {
    // Force rapid turn
    ship.ang += ship._rollDir * CFG.SHIP_TURN_SPEED * 4 * dt;
    // Thrust forward during roll
    ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 1.5 * dt;
    ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 1.5 * dt;
    ship.thrustOn = true;
    // Trail
    if (Math.random() < 0.5) {
      particles.push({
        x: ship.x + rand(-6, 6), y: ship.y + rand(-6, 6),
        vx: rand(-40, 40), vy: rand(-40, 40),
        life: 0.25 * _tl, maxLife: 0.25 * _tl, color: trailColor(ship), size: rand(1, 3),
      });
    }
  }

  if (ship.maneuver === 'quickTurn') {
    // Boomerang arc â€” smooth curve carrying momentum into new direction
    const spd = Math.hypot(ship.vx, ship.vy);
    const cAng = Math.atan2(ship.vy, ship.vx);
    const turnNeeded = shortAngleDist(cAng, ship._quickTurnTarget);
    const turnRate = 8; // radians/sec â€” same as boomerang projectile
    const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
    const nAng = cAng + turn;
    // Accelerate through the arc
    const newSpd = Math.min(spd + 200 * dt, CFG.SHIP_MAX_SPEED * 1.8);
    ship.vx = Math.cos(nAng) * newSpd;
    ship.vy = Math.sin(nAng) * newSpd;
    ship.ang = nAng; // face velocity direction
    ship.thrustOn = true;
    if (Math.abs(turnNeeded) < 0.2) ship._quickTurnDone = true;
    // Arc trail particles
    if (Math.random() < 0.6) {
      const backAng = nAng + Math.PI;
      particles.push({
        x: ship.x + Math.cos(backAng) * ship.r + rand(-4, 4),
        y: ship.y + Math.sin(backAng) * ship.r + rand(-4, 4),
        vx: Math.cos(backAng) * rand(20, 50) + rand(-15, 15),
        vy: Math.sin(backAng) * rand(20, 50) + rand(-15, 15),
        life: rand(0.2, 0.4) * _tl, maxLife: 0.4 * _tl, color: trailColor(ship), size: rand(1.5, 3),
      });
    }
  }

  if (ship.maneuver === 'turretMode') {
    // Rapidly decelerate to 0 â€” but allow turning
    const brakeFactor = 1 - 8.0 * dt;
    ship.vx *= Math.max(0, brakeFactor);
    ship.vy *= Math.max(0, brakeFactor);
    ship._aiThrust = false; // suppress forward thrust
    ship.thrustOn = false;
    // Force firing
    ship._aiShoot = true;
    // Subtle anchor particles
    if (Math.random() < 0.3) {
      particles.push({
        x: ship.x + rand(-8, 8), y: ship.y + rand(-8, 8),
        vx: rand(-15, 15), vy: rand(-15, 15),
        life: 0.2 * _tl, maxLife: 0.2 * _tl, color: trailColor(ship), size: rand(1, 2),
      });
    }
  }

  if (ship.maneuver === 'serpentine') {
    // 3 sweeps, alternating direction, each 0.3s
    const sweepDur = 0.3;
    ship._serpTimer += dt;
    if (ship._serpTimer >= sweepDur) {
      ship._serpTimer -= sweepDur;
      ship._serpDir *= -1;
      ship._serpSweep++;
    }
    // Strong lateral strafe at 3x normal speed
    const perpAng = ship.ang + Math.PI * 0.5 * ship._serpDir;
    const strafeForce = CFG.SHIP_THRUST * 3;
    ship.vx += Math.cos(perpAng) * strafeForce * dt;
    ship.vy += Math.sin(perpAng) * strafeForce * dt;
    // Slight forward thrust to maintain momentum
    ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * 0.5 * dt;
    ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * 0.5 * dt;
    ship.thrustOn = true;
    // Trail
    if (Math.random() < 0.4) {
      particles.push({
        x: ship.x + rand(-5, 5), y: ship.y + rand(-5, 5),
        vx: rand(-30, 30), vy: rand(-30, 30),
        life: 0.2 * _tl, maxLife: 0.2 * _tl, color: trailColor(ship), size: rand(1, 2.5),
      });
    }
  }

  if (ship.maneuver === 'panic') {
    // Spin rapidly â€” no forward thrust
    const spinRate = ship._panicSpinTotal / MANEUVER_DEFS.panic.duration;
    const spinStep = spinRate * dt;
    ship.ang += ship._panicDir * spinStep;
    ship._panicSpinDone += spinStep;
    // Force rapid fire
    ship._aiShoot = true;
    // Frantic particles
    if (Math.random() < 0.5) {
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: ship.x + Math.cos(a) * ship.r, y: ship.y + Math.sin(a) * ship.r,
        vx: Math.cos(a) * rand(40, 80), vy: Math.sin(a) * rand(40, 80),
        life: 0.25 * _tl, maxLife: 0.25 * _tl, color: trailColor(ship), size: rand(1, 3),
      });
    }
  }

  if (ship.maneuver === 'rapidFire') {
    // Force firing, movement handled by normal AI
    ship._aiShoot = true;
    // Subtle muzzle flash particles
    if (Math.random() < 0.3) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      particles.push({
        x: fx, y: fy,
        vx: Math.cos(ship.ang) * rand(30, 60) + rand(-20, 20),
        vy: Math.sin(ship.ang) * rand(30, 60) + rand(-20, 20),
        life: 0.15 * _tl, maxLife: 0.15 * _tl, color: trailColor(ship), size: rand(1, 2),
      });
    }
  }

  if (ship.maneuver === 'spinOut') {
    const totalDur = MANEUVER_DEFS.spinOut.duration;
    const elapsed = totalDur - ship.maneuverTimer;
    if (elapsed < 0.5) {
      // Phase 1: Boomerang arc â€” smooth curve like quick-turn
      ship._spinOutPhase = 'arc';
      ship._aiShoot = false;
      const spd = Math.hypot(ship.vx, ship.vy);
      const cAng = Math.atan2(ship.vy, ship.vx);
      const turnNeeded = shortAngleDist(cAng, ship._spinOutArcTarget);
      const turnRate = 8;
      const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
      const nAng = cAng + turn;
      const newSpd = Math.min(spd + 150 * dt, CFG.SHIP_MAX_SPEED * 1.5);
      ship.vx = Math.cos(nAng) * newSpd;
      ship.vy = Math.sin(nAng) * newSpd;
      ship.ang = nAng;
      ship.thrustOn = true;
      // Arc trail particles
      if (Math.random() < 0.6) {
        const backAng = nAng + Math.PI;
        particles.push({
          x: ship.x + Math.cos(backAng) * ship.r + rand(-4, 4),
          y: ship.y + Math.sin(backAng) * ship.r + rand(-4, 4),
          vx: Math.cos(backAng) * rand(20, 50) + rand(-15, 15),
          vy: Math.sin(backAng) * rand(20, 50) + rand(-15, 15),
          life: rand(0.2, 0.4) * _tl, maxLife: 0.4 * _tl, color: trailColor(ship), size: rand(1.5, 3),
        });
      }
    } else {
      // Phase 2: Brake and prepare for boost
      ship._spinOutPhase = 'brake';
      const brakeFactor = 1 - 5.0 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
      ship.thrustOn = false;
      // Tire-smoke style particles
      if (Math.random() < 0.5) {
        const backAng = ship.ang + Math.PI;
        particles.push({
          x: ship.x + Math.cos(backAng) * ship.r + rand(-6, 6),
          y: ship.y + Math.sin(backAng) * ship.r + rand(-6, 6),
          vx: Math.cos(backAng) * rand(30, 60) + rand(-20, 20),
          vy: Math.sin(backAng) * rand(30, 60) + rand(-20, 20),
          life: rand(0.3, 0.6), maxLife: 0.6, color: '#aaaaaa', size: rand(2, 4),
        });
      }
    }
  }

  if (ship.maneuver === 'reverse') {
    const elapsed = MANEUVER_DEFS.reverse.duration - ship.maneuverTimer;
    if (elapsed < 0.2) {
      // Phase 1: rapid deceleration
      ship._reversePhase = 'decel';
      const brakeFactor = 1 - 10.0 * dt;
      ship.vx *= Math.max(0, brakeFactor);
      ship.vy *= Math.max(0, brakeFactor);
      ship._aiThrust = false;
      ship.thrustOn = false;
    } else {
      // Phase 2: reverse thrust â€” accelerate backwards while AI aims normally
      ship._reversePhase = 'reverse';
      const backAng = ship.ang + Math.PI;
      ship.vx += Math.cos(backAng) * CFG.SHIP_THRUST * dt;
      ship.vy += Math.sin(backAng) * CFG.SHIP_THRUST * dt;
      ship._aiThrust = false; // suppress normal forward thrust
      ship.thrustOn = true;
      ship._aiShoot = true;
      // Reverse thrust particles from front
      if (Math.random() < 0.4) {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        particles.push({
          x: fx + rand(-4, 4), y: fy + rand(-4, 4),
          vx: Math.cos(ship.ang) * rand(40, 80), vy: Math.sin(ship.ang) * rand(40, 80),
          life: 0.25 * _tl, maxLife: 0.25 * _tl, color: trailColor(ship), size: rand(1, 3),
        });
      }
    }
  }

  if (ship.maneuver === 'smokescreen') {
    // Ongoing particle drizzle for first 0.5s
    const elapsed = MANEUVER_DEFS.smokescreen.duration - ship.maneuverTimer;
    if (elapsed < 0.5 && Math.random() < 0.6) {
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: ship.x + rand(-10, 10), y: ship.y + rand(-10, 10),
        vx: Math.cos(a) * rand(15, 50), vy: Math.sin(a) * rand(15, 50),
        life: rand(1.0, 2.0), maxLife: 2.0, color: '#888888', size: rand(3, 6),
      });
    }
  }

  if (ship.maneuver === 'reflectorShields') {
    // Advance orbit angle (fast rotation)
    ship._reflectorAngle += Math.PI * 2.5 * dt; // ~2.5 rev/sec
    // Suppress firing
    ship._aiShoot = false;
  }

  if (ship.maneuver === 'mineField') {
    ship._mineDropTimer -= dt;
    if (ship._mineDropTimer <= 0 && ship._minesDropped < 3) {
      // Drop a mine from the back of the ship
      const backAng = ship.ang + Math.PI;
      mines.push({
        x: ship.x + Math.cos(backAng) * ship.r * 1.5,
        y: ship.y + Math.sin(backAng) * ship.r * 1.5,
        ownerId: ship.id,
        color: ship.color,
        life: 22.5,
        r: 5,
        proximityRadius: 200,
        armTimer: 1.0, // cannot detonate until armed
      });
      ship._minesDropped++;
      ship._mineDropTimer = 0.5; // next mine in 1s
      spawnExplosion(ship.x + Math.cos(backAng) * ship.r * 1.5,
                     ship.y + Math.sin(backAng) * ship.r * 1.5, ship.color, 5, 20);
    }
  }

  // End maneuver
  if (ship.maneuverTimer <= 0) {
    ship.maneuverActive = false;
    ship._hyperSpeedActive = false;

    if (ship.maneuver === 'teleport') {
      // Reappear with burst
      ship._teleportPhase = null;
      ship.vx *= 0.2; ship.vy *= 0.2; // kill most remaining velocity
      spawnExplosion(ship.x, ship.y, ship.color, 15, 80);
      shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 50, life: 0.4, color: ship.color });
    }

    if (ship.maneuver === 'quickTurn') {
      // Increased likelihood to fire immediately after turn
      ship.fireCooldown = 0;
      ship._aiShoot = true;
    }

    if (ship.maneuver === 'spinOut') {
      // Activate post-maneuver accuracy+speed boost
      ship._spinOutBoostTimer = MANEUVER_DEFS.spinOut.afterDuration;
      ship.fireCooldown = 0;
      ship._aiShoot = true;
      spawnExplosion(ship.x, ship.y, ship.color, 8, 50);
    }

    if (ship.maneuver === 'doubleTeam') {
      // Cooldown starts now, after duration ends
      ship.maneuverCooldown = MANEUVER_DEFS.doubleTeam.cooldown;
    }

    if (ship.maneuver === 'reflectorShields') {
      // Remove all shields belonging to this ship
      for (let i = reflectorShields.length - 1; i >= 0; i--) {
        if (reflectorShields[i].ownerId === ship.id) {
          reflectorShields.splice(i, 1);
        }
      }
    }
  }
}

// â”€â”€â”€ WEAPON FIRE SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeBullet(ship, x, y, vx, vy, opts) {
  const o = opts || {};
  const scopeMult = ship.passive === 'scope' ? 1.2 : 1;
  const sparkMult = ship.passive === 'sparkDrive' ? 1.2 : 1;
  return {
    x, y, vx: vx * sparkMult, vy: vy * sparkMult,
    life: (o.life ?? ship.weapon.life) * scopeMult,
    owner: ship.id, ownerTeam: ship.team || 0, color: o.color ?? ship.color,
    damage: (o.damage ?? ship.weapon.damage) * (ship.passive === 'fierce' ? 1.35 : 1),
    type: o.type ?? ship.weapon.type,
    size: o.size ?? 3,
    detonateTime: o.detonateTime ?? null,
    contactDetonate: o.contactDetonate ?? false,
    isShrapnel: o.isShrapnel ?? false,
    armed: o.armed ?? true,
    armTime: o.armTime ?? 0,
    fireAng: o.fireAng ?? ship.ang,
    spawnTime: gameTime,
    curveRate: o.curveRate ?? 0,
    sineAmp: o.sineAmp ?? 0,
    sineFreq: o.sineFreq ?? 0,
    boomerang: o.boomerang ?? false,
    maxLife: o.maxLife ?? null,
    helixSide: o.helixSide ?? 0,
    helixId: o.helixId ?? null,
    helixGrow: o.helixGrow ?? false,
    cyclone: o.cyclone ?? false,
    cycloneAng: o.cycloneAng ?? 0,
    cycloneCx: o.cycloneCx ?? 0,
    cycloneCy: o.cycloneCy ?? 0,
    cycloneFireAng: o.cycloneFireAng ?? 0,
    cycloneSpeed: o.cycloneSpeed ?? 0,
    cycloneId: o.cycloneId ?? null,
    cycloneRadiusMult: o.cycloneRadiusMult ?? 1,
    lightning: o.lightning ?? false,
    lightningZigTimer: o.lightningZigTimer ?? 0,
    lightningOrigAng: o.lightningOrigAng ?? (o.fireAng ?? ship.ang),
    lightningSplitsLeft: o.lightningSplitsLeft ?? 0,
    concussive: o.concussive ?? false,
    concussiveTimer: o.concussiveTimer ?? 0,
    incId: ship.passive === 'incendiary' ? ++incBulletCounter : 0,
    ownerPassive: ship.passive,
  };
}

function removeHelixPartner(b) {
  if (b.type !== 'doublehelix' || !b.helixId) return;
  const partner = bullets.find(o => o !== b && o.helixId === b.helixId);
  if (partner) partner.life = 0; // will be cleaned up on next tick
}

function fireWeapon(ship) {
  const w = ship.weapon;
  const accNoise = ship.maneuverActive && ship.maneuver === 'rapidFire' ? rand(-0.15, 0.15) : 0;
  const ang = ship.ang + accNoise;
  const bx = ship.x + Math.cos(ang) * ship.r * 1.2;
  const by = ship.y + Math.sin(ang) * ship.r * 1.2;
  // Spin Out boost: 50% faster projectiles
  const wSpd = w.speed * (ship._spinOutBoostTimer > 0 ? 1.5 : 1);
  // Scale weapon offsets with ship size (for Flagship etc)
  const sizeScale = ship.r / CFG.SHIP_RADIUS;

  switch (w.type) {
    case 'basic':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3));
      break;

    case 'shotgun': {
      const sr = (w.spread/2) * Math.PI/180;
      for (let i = 0; i < w.pellets; i++) {
        const off = (i/(w.pellets-1) - 0.5) * 2 * sr;
        const a = ang + off;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(a)*wSpd + ship.vx*0.3,
          Math.sin(a)*wSpd + ship.vy*0.3, {size:2}));
      }
      break;
    }

    case 'grenade': {
      const grenSpd = wSpd * rand(0.35, 1.6);
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*grenSpd + ship.vx*0.7,
        Math.sin(ang)*grenSpd + ship.vy*0.7,
        {detonateTime: w.fuseTime, contactDetonate: true, size:5}));
      break;
    }

    case 'triple':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*w.burstDelay, type:'triple'});
      break;

    case 'homing': {
      const perp = ang + Math.PI/2;
      const sOff = ship.r * 1.5;
      for (const side of [-1, 1]) {
        const mx = ship.x + Math.cos(perp)*sOff*side;
        const my = ship.y + Math.sin(perp)*sOff*side;
        bullets.push(makeBullet(ship, mx, my,
          Math.cos(perp)*w.launchSpeed*side,
          Math.sin(perp)*w.launchSpeed*side,
          {armed:false, armTime:w.boostDelay, fireAng:ang, size:4}));
      }
      break;
    }

    case 'alternating': {
      const perp = ang + Math.PI/2;
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*w.offset*sizeScale*side;
        const oy = by + Math.sin(perp)*w.offset*sizeScale*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3));
      }
      break;
    }

    case 'flamethrower':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*0.027, type:'flamethrower', idx:i, total:w.burstCount});
      break;

    case 'sniper':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3, {size:2}));
      break;

    case 'chaotic':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {curveRate: rand(-4, 4), life: w.life * 2}));
      break;

    case 'scrap':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {detonateTime: w.fuseTime, contactDetonate: false, size:4}));
      break;

    case 'snake':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {sineAmp: 8, sineFreq: 14}));
      break;

    case 'gatling':
      for (let i = 0; i < w.burstCount; i++)
        ship.burstQueue.push({time: gameTime + i*w.burstDelay, type:'gatling'});
      break;

    case 'boomerang':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {boomerang: true, maxLife: w.life}));
      break;

    case 'doublehelix': {
      const perp = ang + Math.PI/2;
      const helixId = Math.random();
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*w.offset*sizeScale*side;
        const oy = by + Math.sin(perp)*w.offset*sizeScale*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {sineAmp: 3, sineFreq: 10, helixSide: side, helixId, helixGrow: true}));
      }
      break;
    }

    case 'cyclone': {
      const cId = Math.random();
      for (let i = 0; i < w.projectiles; i++) {
        const orbAng = (i / w.projectiles) * Math.PI * 2;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {cyclone: true, cycloneAng: orbAng, cycloneCx: bx, cycloneCy: by,
           cycloneFireAng: ang, cycloneSpeed: wSpd, cycloneId: cId, size: 2,
           cycloneRadiusMult: rand(0.5, 1.5)}));
      }
      // Inner projectiles â€” stay close to the eye of the storm
      for (let i = 0; i < (w.innerProjectiles || 0); i++) {
        const orbAng = (i / (w.innerProjectiles)) * Math.PI * 2 + rand(0, 1);
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3,
          {cyclone: true, cycloneAng: orbAng, cycloneCx: bx, cycloneCy: by,
           cycloneFireAng: ang, cycloneSpeed: wSpd, cycloneId: cId, size: 2,
           cycloneRadiusMult: rand(0.1, 0.25)}));
      }
      break;
    }

    case 'crossshot': {
      const perp = ang + Math.PI/2;
      const scaledOffset = w.offset * sizeScale;
      const convergeAng = Math.atan2(scaledOffset, w.convergeDist);
      for (const side of [-1, 1]) {
        const ox = bx + Math.cos(perp)*scaledOffset*side;
        const oy = by + Math.sin(perp)*scaledOffset*side;
        const fireAng = ang - convergeAng*side;
        bullets.push(makeBullet(ship, ox, oy,
          Math.cos(fireAng)*wSpd + ship.vx*0.3,
          Math.sin(fireAng)*wSpd + ship.vy*0.3));
      }
      break;
    }

    case 'lightning':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {lightning: true, lightningZigTimer: rand(0.03, 0.06), lightningOrigAng: ang, lightningSplitsLeft: 2}));
      break;

    case 'concussive':
      bullets.push(makeBullet(ship, bx, by,
        Math.cos(ang)*wSpd + ship.vx*0.3,
        Math.sin(ang)*wSpd + ship.vy*0.3,
        {concussive: true, concussiveTimer: rand(0.3, 1.0) * w.life}));
      break;
  }
  const lowSoundWeapons = ['shotgun', 'scrap'];
  const riseSoundWeapons = ['chaotic', 'snake'];
  if (lowSoundWeapons.includes(w.type)) playShootLow();
  else if (riseSoundWeapons.includes(w.type)) playShootRise();
  else if (w.type === 'sniper') playShootSniper();
  else if (w.type === 'alternating' || w.type === 'crossshot') playShootAlt();
  else if (w.type === 'lightning') playShootSniper();
  else if (w.type === 'concussive') playShootLow();
  else playShoot();
}

function processBurstQueue(ship) {
  while (ship.burstQueue.length > 0 && gameTime >= ship.burstQueue[0].time) {
    const burst = ship.burstQueue.shift();
    const w = ship.weapon;
    const accNoise2 = ship.maneuverActive && ship.maneuver === 'rapidFire' ? rand(-0.15, 0.15) : 0;
    const ang = ship.ang + accNoise2;
    const bx = ship.x + Math.cos(ang)*ship.r*1.2;
    const by = ship.y + Math.sin(ang)*ship.r*1.2;
    const wSpd = w.speed * (ship._spinOutBoostTimer > 0 ? 1.5 : 1);
    switch (burst.type) {
      case 'triple':
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(ang)*wSpd + ship.vx*0.3,
          Math.sin(ang)*wSpd + ship.vy*0.3));
        break;
      case 'flamethrower': {
        const t = burst.idx / burst.total;
        const sOff = Math.sin(t * Math.PI * 4) * (w.amplitude * Math.PI/180);
        const a = ang + sOff;
        bullets.push(makeBullet(ship, bx, by,
          Math.cos(a)*wSpd + ship.vx*0.8,
          Math.sin(a)*wSpd + ship.vy*0.8,
          {life: rand(1.5, 2.5), size: 0.5}));
        break;
      }
      case 'gatling': {
        const sr = (w.spread/2) * Math.PI/180;
        const a = ang + rand(-sr, sr);
        const perp = ang + Math.PI/2;
        const gOffset = rand(-6, 6);
        const gx = bx + Math.cos(perp) * gOffset;
        const gy = by + Math.sin(perp) * gOffset;
        bullets.push(makeBullet(ship, gx, gy,
          Math.cos(a)*wSpd + ship.vx*0.3,
          Math.sin(a)*wSpd + ship.vy*0.3, {size:2}));
        break;
      }
    }
    if (burst.type === 'flamethrower') playShootFlame();
    else playShoot();
  }
}

function detonateBullet(b) {
  if (b.isShrapnel) return;
  if (b.type === 'grenade') {
    // Particles only, no shockwave
    for (let i = 0; i < 12; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(20, 80);
      particles.push({ x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.3,1.2), maxLife:1.2, color:b.color, size:rand(1,3) });
    }
    playAsteroidBreak();
    for (let i = 0; i < 16; i++) {
      const a = (i/16) * Math.PI * 2;
      bullets.push({
        x:b.x, y:b.y, vx:Math.cos(a)*500, vy:Math.sin(a)*500,
        life:0.4, owner:b.owner, color:b.color, damage:2, type:'grenade',
        size:2, isShrapnel:true, contactDetonate:false, detonateTime:null,
        armed:true, armTime:0, fireAng:a, spawnTime:gameTime,
        curveRate:0, sineAmp:0, sineFreq:0,
      });
    }
    // Repulsor effect â€” push asteroids and enemy bullets away
    const repulsorRadius = 240;
    const repulsorForce = 200;
    for (const ast of asteroids) {
      const d = dist(b, ast);
      if (d < repulsorRadius && d > 0) {
        const pushAng = Math.atan2(ast.y - b.y, ast.x - b.x);
        const strength = 1 - (d / repulsorRadius); // stronger closer
        ast.vx += Math.cos(pushAng) * repulsorForce * strength;
        ast.vy += Math.sin(pushAng) * repulsorForce * strength;
      }
    }
    for (const ob of bullets) {
      if (ob.owner === b.owner || ob.isShrapnel) continue;
      const d = dist(b, ob);
      if (d < repulsorRadius && d > 0) {
        const pushAng = Math.atan2(ob.y - b.y, ob.x - b.x);
        const strength = 1 - (d / repulsorRadius);
        ob.vx += Math.cos(pushAng) * repulsorForce * strength;
        ob.vy += Math.sin(pushAng) * repulsorForce * strength;
      }
    }
    // Repulsor shockwave ring
    shockwaves.push({ x: b.x, y: b.y, r: 0, maxR: 240, life: 0.35, color: b.color });
  } else if (b.type === 'scrap') {
    // Particles only, no shockwave
    for (let i = 0; i < 6; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(15, 50);
      particles.push({ x:b.x, y:b.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.2,0.8), maxLife:0.8, color:b.color, size:rand(1,2.5) });
    }
    playShootLow();
    const baseAng = Math.atan2(b.vy, b.vx);
    const sr = (20/2) * Math.PI/180;
    for (let i = 0; i < 5; i++) {
      const off = (i/4 - 0.5) * 2 * sr;
      const a = baseAng + off;
      bullets.push({
        x:b.x, y:b.y, vx:Math.cos(a)*400, vy:Math.sin(a)*400,
        life:b.life, owner:b.owner, color:b.color, damage:2, type:'scrap',
        size:2, isShrapnel:true, contactDetonate:false, detonateTime:null,
        armed:true, armTime:0, fireAng:a, spawnTime:gameTime,
        curveRate:0, sineAmp:0, sineFreq:0,
      });
    }
  }
}


// â”€â”€â”€ MATCH SETUP STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAX_TEAMS = 6;
const DEFAULT_TEAM_COLORS = ['#ff5050','#5096ff','#50ff50','#ffcc00','#ff50ff','#50ffff'];
let matchMode = 'ffa'; // 'ffa' or 'teams'
let teams = [[], []]; // array of arrays of ship indices
let teamWeapons = [[], []]; // per-team weapon key selections (empty = use global settings)
let teamPassives = [[], []]; // per-team passive key selections
let teamManeuvers = [[], []]; // per-team maneuver key selections
let selectedShips = []; // array of ship indices (FFA mode)
let assignTarget = 0; // which team index gets next click in team mode
let teamNames = ['TEAM 1', 'TEAM 2'];
const setupSettings = {
  weapons: false,
  passives: false,
  maneuvers: false,
  randomLoadouts: false,
  uniqueShips: false,
  shipHP: 3,
};

function setMode(mode) {
  matchMode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
  const teamsArea = document.getElementById('teams-area');
  const label = document.getElementById('roster-label');
  if (mode === 'ffa') {
    teamsArea.classList.add('hidden');
    label.textContent = 'TAP TO SELECT FIGHTERS';
    const merged = [...new Set([...teams.flat(), ...selectedShips])];
    selectedShips = merged;
    teams = [[], []];
    teamNames = ['TEAM 1', 'TEAM 2'];
    teamWeapons = [[], []];
    teamPassives = [[], []];
    teamManeuvers = [[], []];
  } else {
    teamsArea.classList.remove('hidden');
    label.textContent = 'TAP TO ADD FIGHTERS';
    assignTarget = 0;
    selectedShips = [];
  }
  renderSetup();
}

function toggleSetup(el) {
  const key = el.dataset.key;
  setupSettings[key] = !setupSettings[key];
  el.classList.toggle('on', setupSettings[key]);
}

function editTeamName(t) {
  const header = document.getElementById(`team-header-${t}`);
  if (!header) return;
  const input = document.createElement('input');
  input.type = 'text';
  input.value = teamNames[t];
  input.maxLength = 16;
  const tc = getTeamColors();
  input.style.cssText = `
    background: transparent; border: none; border-bottom: 1px solid ${tc[t] || '#fff'}80;
    color: inherit; font-family: 'Orbitron', sans-serif; font-size: inherit; font-weight: inherit;
    letter-spacing: inherit; text-align: center; width: 100%; outline: none; padding: 0;
  `;
  const commit = () => {
    const val = input.value.trim();
    teamNames[t] = val || `TEAM ${t + 1}`;
    header.textContent = teamNames[t];
  };
  input.addEventListener('blur', commit);
  input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); });
  header.textContent = '';
  header.appendChild(input);
  input.focus();
  input.select();
}

function addTeam() {
  if (teams.length >= MAX_TEAMS) return;
  teams.push([]);
  teamNames.push(`TEAM ${teams.length}`);
  teamWeapons.push([]);
  teamPassives.push([]);
  teamManeuvers.push([]);
  assignTarget = teams.length - 1;
  renderSetup();
}

function removeTeam(t) {
  if (teams.length <= 2) return;
  teams.splice(t, 1);
  teamNames.splice(t, 1);
  teamWeapons.splice(t, 1);
  teamPassives.splice(t, 1);
  teamManeuvers.splice(t, 1);
  if (assignTarget >= teams.length) assignTarget = teams.length - 1;
  renderSetup();
}

function assignShip(shipIdx) {
  if (matchMode === 'ffa') {
    const pos = selectedShips.indexOf(shipIdx);
    if (pos >= 0) {
      selectedShips.splice(pos, 1);
    } else {
      selectedShips.push(shipIdx);
    }
  } else {
    teams[assignTarget].push(shipIdx);
  }
  renderSetup();
}

function removeFromTeam(teamIdx, slotIdx) {
  if (slotIdx >= 0 && slotIdx < teams[teamIdx].length) teams[teamIdx].splice(slotIdx, 1);
  renderSetup();
}

let _activeWpnDropdown = null;
function closeWeaponDropdown() {
  if (_activeWpnDropdown) { _activeWpnDropdown.remove(); _activeWpnDropdown = null; }
}
function toggleLoadoutDropdown(teamIdx, btn, type) {
  const ddKey = `${type}-${teamIdx}`;
  if (_activeWpnDropdown && _activeWpnDropdown._ddKey === ddKey) {
    closeWeaponDropdown(); return;
  }
  closeWeaponDropdown();
  const dd = document.createElement('div');
  dd.className = 'team-wpn-dropdown';
  dd._ddKey = ddKey;

  let keys, defs, stateArr;
  if (type === 'weapons') { keys = Object.keys(WEAPON_DEFS); defs = WEAPON_DEFS; stateArr = teamWeapons; }
  else if (type === 'passives') { keys = PASSIVE_KEYS; defs = PASSIVE_DEFS; stateArr = teamPassives; }
  else { keys = MANEUVER_KEYS; defs = MANEUVER_DEFS; stateArr = teamManeuvers; }

  for (const key of keys) {
    const item = document.createElement('label');
    item.className = 'team-wpn-item';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = stateArr[teamIdx].includes(key);
    cb.onchange = () => {
      if (cb.checked) {
        if (!stateArr[teamIdx].includes(key)) stateArr[teamIdx].push(key);
      } else {
        stateArr[teamIdx] = stateArr[teamIdx].filter(k => k !== key);
      }
      // Update button label without re-rendering
      const btns = document.querySelectorAll(`.team-wpn-btn[data-type="${type}"]`);
      const btn = btns[teamIdx];
      if (btn) {
        const count = stateArr[teamIdx].length;
        const icon = type === 'weapons' ? 'âš”' : type === 'passives' ? 'â—ˆ' : 'â†»';
        btn.textContent = count === 0 ? icon : count === 1 ? defs[stateArr[teamIdx][0]]?.name || stateArr[teamIdx][0] : `${icon}${count}`;
        btn.classList.toggle('active', count > 0);
      }
    };
    item.appendChild(cb);
    const label = document.createElement('span');
    label.textContent = defs[key].name;
    item.appendChild(label);
    dd.appendChild(item);
  }

  const rect = btn.getBoundingClientRect();
  dd.style.position = 'fixed';
  dd.style.top = rect.bottom + 2 + 'px';
  // Clamp to viewport
  const leftPos = Math.min(rect.left, window.innerWidth - 140);
  dd.style.left = Math.max(0, leftPos) + 'px';
  document.body.appendChild(dd);
  _activeWpnDropdown = dd;
}
document.addEventListener('click', (e) => {
  if (_activeWpnDropdown && !_activeWpnDropdown.contains(e.target) && !e.target.classList.contains('team-wpn-btn')) {
    closeWeaponDropdown();
  }
});

function renderSetup() {
  const teamsArea = document.getElementById('teams-area');

  // Render team columns (only in team mode)
  if (matchMode === 'teams') {
    teamsArea.innerHTML = '';
    const tc = getTeamColors();

    for (let t = 0; t < teams.length; t++) {
      const col = document.createElement('div');
      col.className = 'team-col';
      col.style.borderColor = (tc[t] || '#888') + '40';

      const header = document.createElement('div');
      header.className = 'team-header';
      header.id = `team-header-${t}`;
      header.style.color = tc[t] || '#888';
      header.textContent = teamNames[t];
      header.ondblclick = () => editTeamName(t);
      col.appendChild(header);

      // Loadout selector buttons row
      const loadoutRow = document.createElement('div');
      loadoutRow.style.cssText = 'display:flex; gap:2px; margin-bottom:2px;';
      const loadoutTypes = [
        { type: 'weapons', arr: teamWeapons, defs: WEAPON_DEFS, icon: 'âš”' },
        { type: 'passives', arr: teamPassives, defs: PASSIVE_DEFS, icon: 'â—ˆ' },
        { type: 'maneuvers', arr: teamManeuvers, defs: MANEUVER_DEFS, icon: 'â†»' },
      ];
      for (const lt of loadoutTypes) {
        const btn = document.createElement('div');
        btn.className = 'team-wpn-btn' + (lt.arr[t].length > 0 ? ' active' : '');
        btn.setAttribute('data-type', lt.type);
        btn.title = lt.type.charAt(0).toUpperCase() + lt.type.slice(1);
        const count = lt.arr[t].length;
        btn.textContent = count === 0 ? `${lt.icon}` : count === 1 ? lt.defs[lt.arr[t][0]]?.name || lt.arr[t][0] : `${lt.icon}${count}`;
        btn.style.flex = '1';
        const _type = lt.type, _t = t;
        btn.onclick = (e) => { e.stopPropagation(); toggleLoadoutDropdown(_t, btn, _type); };
        loadoutRow.appendChild(btn);
      }
      col.appendChild(loadoutRow);

      const slots = document.createElement('div');
      slots.className = 'team-slots';

      // Filled slots
      for (let i = 0; i < teams[t].length; i++) {
        const si = teams[t][i];
        const slot = document.createElement('div');
        slot.className = 'team-slot filled';
        slot.appendChild(createShipIcon(si, PILOT_COLORS[si], 20));
        const name = document.createElement('span');
        name.className = 'slot-name';
        name.style.color = PILOT_COLORS[si];
        name.textContent = PILOT_NAMES[si];
        slot.appendChild(name);
        const rem = document.createElement('span');
        rem.className = 'slot-remove';
        rem.textContent = 'âœ•';
        const slotIdx = i;
        rem.onclick = (e) => { e.stopPropagation(); removeFromTeam(t, slotIdx); };
        slot.appendChild(rem);
        slots.appendChild(slot);
      }

      // Add fighter slot
      const addSlot = document.createElement('div');
      addSlot.className = 'team-slot empty';
      addSlot.style.cursor = 'pointer';
      if (assignTarget === t) addSlot.style.borderColor = (tc[t] || '#888') + '80';
      const addLabel = document.createElement('span');
      addLabel.className = 'slot-name';
      addLabel.textContent = '+ Add';
      addSlot.appendChild(addLabel);
      addSlot.onclick = () => { assignTarget = t; renderSetup(); };
      slots.appendChild(addSlot);

      col.appendChild(slots);

      // Remove team button (if >2 teams)
      if (teams.length > 2) {
        const remBtn = document.createElement('div');
        remBtn.style.cssText = 'text-align:center; font-size:8px; color:rgba(255,255,255,0.2); cursor:pointer; padding:2px 0;';
        remBtn.textContent = 'âœ• remove';
        remBtn.onclick = () => removeTeam(t);
        col.appendChild(remBtn);
      }

      teamsArea.appendChild(col);
    }

    // Add team button
    if (teams.length < MAX_TEAMS) {
      const addCol = document.createElement('div');
      addCol.className = 'team-col';
      addCol.style.cssText = 'cursor:pointer; align-items:center; justify-content:center; min-height:60px; opacity:0.4; border-style:dashed;';
      addCol.innerHTML = '<div style="font-family:Orbitron,sans-serif; font-size:clamp(8px,2vw,12px); letter-spacing:2px; color:rgba(255,255,255,0.5);">+ TEAM</div>';
      addCol.onclick = addTeam;
      teamsArea.appendChild(addCol);
    }
  }

  // Render roster grid
  const grid = document.getElementById('roster-grid');
  grid.innerHTML = '';
  for (let i = 0; i < PILOT_NAMES.length; i++) {
    const el = document.createElement('div');
    el.className = 'roster-ship';
    if (matchMode === 'ffa') {
      if (selectedShips.includes(i)) el.classList.add('selected');
    }
    el.appendChild(createShipIcon(i, PILOT_COLORS[i], 20));
    const name = document.createElement('span');
    name.className = 'rs-name';
    name.style.color = PILOT_COLORS[i];
    name.textContent = PILOT_NAMES[i];
    el.appendChild(name);
    el.onclick = () => assignShip(i);
    grid.appendChild(el);
  }

  // Update start button
  const btn = document.getElementById('start-match-btn');
  if (matchMode === 'ffa') {
    const n = selectedShips.length;
    const ready = n >= 2;
    btn.disabled = !ready;
    btn.textContent = ready ? `FIGHT (${n})` : `SELECT ${2 - n} MORE`;
  } else {
    const filledTeams = teams.filter(t => t.length >= 1).length;
    const ready = filledTeams >= 2;
    btn.disabled = !ready;
    const sizes = teams.filter(t => t.length > 0).map(t => t.length).join('v');
    btn.textContent = ready ? `FIGHT (${sizes})` : 'ADD FIGHTERS';
  }
}

function buildHPRow() {
  const row = document.getElementById('hp-row');
  row.innerHTML = '';
  for (const hp of [1, 3, 5, 8, 10]) {
    const btn = document.createElement('button');
    btn.className = 'hp-btn2' + (hp === setupSettings.shipHP ? ' active' : '');
    btn.textContent = hp + 'HP';
    btn.onclick = () => {
      setupSettings.shipHP = hp;
      row.querySelectorAll('.hp-btn2').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    };
    row.appendChild(btn);
  }
}

function autoFill() {
  const all = Array.from({length: 16}, (_, i) => i);
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  if (matchMode === 'ffa') {
    const count = randInt(4, 12);
    selectedShips = all.slice(0, count);
  } else {
    let idx = 0;
    for (let t = 0; t < teams.length; t++) {
      const count = randInt(1, 4);
      teams[t] = [];
      for (let i = 0; i < count; i++) teams[t].push(all[(idx++) % all.length]);
    }
  }
  renderSetup();
}

// â”€â”€â”€ SETTINGS (simplified for versus) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const settings = {
  randomPersonalities: false,
  weapons: true,
  randomWeapons: false,
  passives: true,
  maneuvers: true,
  shipHP: 5,
  numShips: 2,
  autoRestart: false,
  chaosMode: false,
  matchLogger: false,
  showWeaponTag: true,
  showPassiveTag: true,
  showManeuverTag: true,
};
function toggleSetting() {} // no-op for compatibility
// â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
let masterGain = null;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  masterGain.gain.value = 0.4;
}

function ensureAudio() {
  if (!audioCtx) initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

// Volume scales with zoom: zoomed in = loud, zoomed out = quiet
function getZoomVolume() {
  if (!audioCtx) return 0;
  return Math.max(0.03, Math.min(1.0, camZoom * 0.7));
}

// Throttle sounds to avoid overload
let lastShootTime = 0;
let lastAsteroidTime = 0;

function playShoot() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootTime < 0.04) return; // max ~25 shots/sec
  lastShootTime = t;
  const vol = getZoomVolume() * 0.06;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(800, t);
  osc.frequency.exponentialRampToValueAtTime(200, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
  osc.start(t);
  osc.stop(t + 0.08);
}

let lastShootLowTime = 0;
function playShootLow() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootLowTime < 0.04) return;
  lastShootLowTime = t;
  const vol = getZoomVolume() * 0.08;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(400, t);
  osc.frequency.exponentialRampToValueAtTime(120, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  osc.start(t);
  osc.stop(t + 0.1);
}

let lastShootRiseTime = 0;
function playShootRise() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootRiseTime < 0.04) return;
  lastShootRiseTime = t;
  const vol = getZoomVolume() * 0.06;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  osc.start(t);
  osc.stop(t + 0.12);
}

let lastShootAltTime = 0;
function playShootAlt() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootAltTime < 0.04) return;
  lastShootAltTime = t;
  const vol = getZoomVolume() * 0.045;
  // Two detuned oscillators sweeping down for TIE-fighter zap
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc1.type = 'sawtooth';
  osc2.type = 'square';
  // Fast sweep down with second osc slightly offset for beating
  osc1.frequency.setValueAtTime(900, t);
  osc1.frequency.exponentialRampToValueAtTime(120, t + 0.08);
  osc2.frequency.setValueAtTime(950, t);
  osc2.frequency.exponentialRampToValueAtTime(130, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.setValueAtTime(vol * 0.3, t + 0.025);
  gain.gain.setValueAtTime(vol * 0.9, t + 0.04);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.09);
  osc1.start(t);
  osc2.start(t);
  osc1.stop(t + 0.09);
  osc2.stop(t + 0.09);
}

let lastShootFlameTime = 0;
function playShootFlame() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootFlameTime < 0.04) return;
  lastShootFlameTime = t;
  const vol = getZoomVolume() * 0.025;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(300, t);
  osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
  osc.start(t);
  osc.stop(t + 0.08);
}

let lastShootSniperTime = 0;
function playShootSniper() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastShootSniperTime < 0.04) return;
  lastShootSniperTime = t;
  const vol = getZoomVolume() * 0.1;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(1200, t);
  osc.frequency.exponentialRampToValueAtTime(400, t + 0.1);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  osc.start(t);
  osc.stop(t + 0.1);
}

function playAsteroidBreak() {
  ensureAudio();
  const t = audioCtx.currentTime;
  if (t - lastAsteroidTime < 0.05) return;
  lastAsteroidTime = t;
  const vol = getZoomVolume() * 0.125;
  // Noise burst via oscillator detune trick
  const osc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc.type = 'sawtooth';
  osc2.type = 'square';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
  osc2.frequency.setValueAtTime(90, t);
  osc2.frequency.exponentialRampToValueAtTime(20, t + 0.15);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  osc.start(t);
  osc2.start(t);
  osc.stop(t + 0.2);
  osc2.stop(t + 0.2);
}

function playShipHit() {
  ensureAudio();
  const vol = getZoomVolume() * 0.3;
  const t = audioCtx.currentTime;
  // Crunchy impact
  const osc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  osc2.connect(gain);
  gain.connect(masterGain);
  osc.type = 'sawtooth';
  osc2.type = 'triangle';
  osc.frequency.setValueAtTime(300, t);
  osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
  osc2.frequency.setValueAtTime(180, t);
  osc2.frequency.exponentialRampToValueAtTime(30, t + 0.15);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
  osc.start(t);
  osc2.start(t);
  osc.stop(t + 0.15);
  osc2.stop(t + 0.15);
}

function playExplosion() {
  ensureAudio();
  const vol = getZoomVolume() * 0.4;
  const t = audioCtx.currentTime;
  // Classic arcade descending "bwaaaa-pop" 
  // High pitched descending whistle
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.connect(gain1);
  gain1.connect(masterGain);
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(1200, t);
  osc1.frequency.exponentialRampToValueAtTime(80, t + 0.35);
  gain1.gain.setValueAtTime(vol * 0.6, t);
  gain1.gain.linearRampToValueAtTime(vol * 0.3, t + 0.1);
  gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
  osc1.start(t);
  osc1.stop(t + 0.4);
  // Crunchy "pop" burst
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.connect(gain2);
  gain2.connect(masterGain);
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(600, t);
  osc2.frequency.exponentialRampToValueAtTime(40, t + 0.2);
  gain2.gain.setValueAtTime(vol * 0.5, t);
  gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
  osc2.start(t);
  osc2.stop(t + 0.25);
  // Wobbly ring-out
  const osc3 = audioCtx.createOscillator();
  const gain3 = audioCtx.createGain();
  osc3.connect(gain3);
  gain3.connect(masterGain);
  osc3.type = 'triangle';
  osc3.frequency.setValueAtTime(300, t + 0.05);
  osc3.frequency.setValueAtTime(350, t + 0.1);
  osc3.frequency.setValueAtTime(200, t + 0.15);
  osc3.frequency.setValueAtTime(250, t + 0.2);
  osc3.frequency.exponentialRampToValueAtTime(60, t + 0.5);
  gain3.gain.setValueAtTime(0.001, t);
  gain3.gain.linearRampToValueAtTime(vol * 0.35, t + 0.05);
  gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
  osc3.start(t);
  osc3.stop(t + 0.5);
}

function playFinaleExplosion() {
  ensureAudio();
  const t = audioCtx.currentTime;
  const vol = 0.6;
  // Big dramatic descending sweep
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.connect(gain1);
  gain1.connect(masterGain);
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(1800, t);
  osc1.frequency.exponentialRampToValueAtTime(30, t + 0.8);
  gain1.gain.setValueAtTime(vol * 0.7, t);
  gain1.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
  osc1.start(t);
  osc1.stop(t + 1.0);
  // Chunky square crunch
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.connect(gain2);
  gain2.connect(masterGain);
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(800, t);
  osc2.frequency.exponentialRampToValueAtTime(25, t + 0.5);
  gain2.gain.setValueAtTime(vol * 0.5, t);
  gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
  osc2.start(t);
  osc2.stop(t + 0.6);
  // Wobble ring-out â€” longer, more dramatic
  const osc3 = audioCtx.createOscillator();
  const gain3 = audioCtx.createGain();
  osc3.connect(gain3);
  gain3.connect(masterGain);
  osc3.type = 'triangle';
  osc3.frequency.setValueAtTime(500, t + 0.05);
  osc3.frequency.setValueAtTime(400, t + 0.12);
  osc3.frequency.setValueAtTime(300, t + 0.2);
  osc3.frequency.setValueAtTime(350, t + 0.3);
  osc3.frequency.setValueAtTime(200, t + 0.4);
  osc3.frequency.exponentialRampToValueAtTime(40, t + 1.2);
  gain3.gain.setValueAtTime(0.001, t);
  gain3.gain.linearRampToValueAtTime(vol * 0.4, t + 0.08);
  gain3.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
  osc3.start(t);
  osc3.stop(t + 1.2);
  // Sub bass thud
  const osc4 = audioCtx.createOscillator();
  const gain4 = audioCtx.createGain();
  osc4.connect(gain4);
  gain4.connect(masterGain);
  osc4.type = 'sine';
  osc4.frequency.setValueAtTime(60, t);
  osc4.frequency.exponentialRampToValueAtTime(15, t + 0.8);
  gain4.gain.setValueAtTime(vol * 0.8, t);
  gain4.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
  osc4.start(t);
  osc4.stop(t + 1.0);
}

function playDebuff() {
  ensureAudio();
  const vol = getZoomVolume() * 0.02;
  const t = audioCtx.currentTime;
  // Pixelated descending square wave "pwshh"
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(masterGain);
  osc.type = 'square';
  osc.frequency.setValueAtTime(280, t);
  osc.frequency.setValueAtTime(220, t + 0.04);
  osc.frequency.setValueAtTime(160, t + 0.08);
  osc.frequency.setValueAtTime(110, t + 0.14);
  osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
  gain.gain.setValueAtTime(vol * 0.4, t);
  gain.gain.linearRampToValueAtTime(vol * 0.25, t + 0.1);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  osc.start(t);
  osc.stop(t + 0.35);
}

function drawShipShape(ctx, x, y, ang, r, color, hp, maxHp, invuln, shipId, hpBarTimer) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(ang);

  if (invuln && isFinite(invuln)) {
    ctx.globalAlpha = 0.3 + 0.3 * Math.sin(gameTime * 15);
  }

  // Thruster glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 20;

  const effectiveId = setupSettings.uniqueShips ? shipId : CHEVRON_ID;
  const verts = (effectiveId != null && SHIP_SHAPES[effectiveId]) ? SHIP_SHAPES[effectiveId] : SHIP_SHAPES[CHEVRON_ID]; // fallback to chevron

  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(verts[0][0] * r, verts[0][1] * r);
  for (let i = 1; i < verts.length; i++) {
    ctx.lineTo(verts[i][0] * r, verts[i][1] * r);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = color + '22';
  ctx.fill();

  // HP bar â€” only show when hit (fades after 1.5s)
  if (maxHp > 1 && hpBarTimer > 0) {
    const barAlpha = Math.min(1, hpBarTimer / 0.4); // fade out over last 0.4s
    ctx.rotate(-ang); // un-rotate so bar is always horizontal
    const barW = r * 2.2;
    const barH = 3;
    const barY = -r - 8;
    // Background
    ctx.fillStyle = `rgba(255,255,255,${0.15 * barAlpha})`;
    ctx.fillRect(-barW/2, barY, barW, barH);
    // Fill
    const pct = hp / maxHp;
    const barColor = pct > 1 ? '#ffffff' : pct > 0.5 ? color : pct > 0.25 ? '#ffaa22' : '#ff4444';
    ctx.globalAlpha = (invuln && isFinite(invuln)) ? (0.3 + 0.3 * Math.sin(gameTime * 15)) * barAlpha : barAlpha;
    ctx.fillStyle = barColor;
    ctx.fillRect(-barW/2, barY, barW * Math.min(pct, 1), barH);
  }

  ctx.restore();
}


// â”€â”€â”€ ASTEROID SHAPE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeAsteroidVerts(r) {
  const n = r > 100 ? randInt(14, 20) : randInt(7, 12);
  const verts = [];
  for (let i = 0; i < n; i++) {
    const a = (i / n) * Math.PI * 2;
    const d = r * rand(0.7, 1.0);
    verts.push({ x: Math.cos(a) * d, y: Math.sin(a) * d });
  }
  return verts;
}

// â”€â”€â”€ SPAWN ASTEROID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnAsteroid(sizeIdx, x, y) {
  const r = CFG.ASTEROID_SIZES[sizeIdx || 0];
  const a = rand(0, Math.PI * 2);
  // Mega asteroids drift slowly, others normal speed
  const speedMult = sizeIdx === 0 ? 0.3 : 1;
  const sp = rand(CFG.ASTEROID_SPEED_MIN, CFG.ASTEROID_SPEED_MAX) * speedMult;
  return {
    x: x ?? rand(0, CFG.WORLD_W),
    y: y ?? rand(0, CFG.WORLD_H),
    vx: Math.cos(a) * sp,
    vy: Math.sin(a) * sp,
    r: r,
    sizeIdx: sizeIdx || 0,
    rot: 0,
    rotSpeed: rand(-2, 2) * (sizeIdx === 0 ? 0.3 : 1),
    verts: makeAsteroidVerts(r),
  };
}

function spawnAsteroidOffscreen(sizeIdx) {
  const margin = 600; // spawn well outside world bounds
  const edge = randInt(0, 3);
  let ex, ey;
  if (edge === 0) { ex = -margin; ey = rand(0, CFG.WORLD_H); }        // left
  else if (edge === 1) { ex = CFG.WORLD_W + margin; ey = rand(0, CFG.WORLD_H); } // right
  else if (edge === 2) { ex = rand(0, CFG.WORLD_W); ey = -margin; }    // top
  else { ex = rand(0, CFG.WORLD_W); ey = CFG.WORLD_H + margin; }       // bottom
  const ast = spawnAsteroid(sizeIdx, ex, ey);
  // Aim towards a random point in the inner world
  const tx = rand(CFG.WORLD_W * 0.2, CFG.WORLD_W * 0.8);
  const ty = rand(CFG.WORLD_H * 0.2, CFG.WORLD_H * 0.8);
  const ang = Math.atan2(ty - ey, tx - ex);
  const sp = rand(CFG.ASTEROID_SPEED_MIN, CFG.ASTEROID_SPEED_MAX);
  ast.vx = Math.cos(ang) * sp;
  ast.vy = Math.sin(ang) * sp;
  return ast;
}
function applyChaosMode() {
  if (!settings.chaosMode) return;

  const shipOptions = [4, 6, 8, 10, 12, 14, 16];

  // 20% chance of a fully default match
  if (Math.random() < 0.2) {
    settings.randomPersonalities = false;
    settings.weapons = true;
    settings.randomWeapons = false;
    settings.passives = true;
    settings.maneuvers = true;
    settings.numShips = 16;
  } else {
    settings.randomPersonalities = Math.random() < 0.5;
    // Weapon modes: 40% unique, 30% random, 30% basic
    const wpnRoll = Math.random();
    if (wpnRoll < 0.4) {
      settings.weapons = true;
      settings.randomWeapons = false;
    } else if (wpnRoll < 0.7) {
      settings.weapons = true;
      settings.randomWeapons = true;
    } else {
      settings.weapons = false;
      settings.randomWeapons = false;
    }
    settings.numShips = shipOptions[randInt(0, shipOptions.length - 1)];
    settings.passives = Math.random() < 0.6;
    settings.maneuvers = Math.random() < 0.4;
  }

  // Sync UI toggles
  document.querySelector('[data-setting="randomPersonalities"]').classList.toggle('on', settings.randomPersonalities);
  document.querySelector('[data-setting="weapons"]').classList.toggle('on', settings.weapons);
  document.querySelector('[data-setting="randomWeapons"]').classList.toggle('on', settings.randomWeapons);
  document.querySelector('[data-setting="passives"]').classList.toggle('on', settings.passives);
  document.querySelector('[data-setting="maneuvers"]').classList.toggle('on', settings.maneuvers);

  // Sync ship count buttons
  document.querySelectorAll('#ship-count-selector .hp-btn').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.ships) === settings.numShips);
  });
}


// â”€â”€â”€ GLOBALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let W, H;
let ships = [];
let _origTeamSizes = [];
let _teamCoreColors = [];

function lerpHexColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
  return '#' + ((1<<24)|(r<<16)|(g<<8)|b).toString(16).slice(1);
}
let shipById = {};
let teamPalettes = {};

function trailColor(ship) {
  const p = teamPalettes[ship.team];
  return (p && p.length > 1) ? p[randInt(0, p.length - 1)] : ship.color;
}

function getTeamColors() {
  const count = (arr) => {
    const freq = {};
    for (const idx of arr) { const c = PILOT_COLORS[idx]; freq[c] = (freq[c] || 0) + 1; }
    return freq;
  };
  const best = (freq, excludeSet) => {
    let top = null, topN = 0;
    for (const [c, n] of Object.entries(freq)) {
      if (excludeSet.has(c)) continue;
      if (n > topN) { topN = n; top = c; }
    }
    return top;
  };
  const result = [];
  const used = new Set();
  for (let t = 0; t < teams.length; t++) {
    const freq = count(teams[t]);
    let c = best(freq, used);
    if (!c) c = best(freq, new Set()); // fallback: allow overlap
    if (!c) c = DEFAULT_TEAM_COLORS[t % DEFAULT_TEAM_COLORS.length];
    result.push(c);
    used.add(c);
  }
  return result;
}
let asteroids = [];
let bullets = [];
let particles = [];
let shockwaves = [];
let smokeDecoys = [];
let shipClones = [];
let debrisField = [];
let reflectorShields = [];
let mines = [];
let shipDrones = [];
let orphanTrails = [];
let deathGlows = [];
let incBulletCounter = 0;
let incSpentBullets = new Set();
let gameTime = 0;
let gameOver = false;
let pregame = true;
let countdown = false;
let countdownTimer = 0;
const COUNTDOWN_DURATION = 3;
let winner = null;
let simSpeed = 1;
let finaleMode = false;
let finaleTimer = 0;
let finaleSlowMo = 1;
let finaleDeath = null;
let finaleFlash = 0;
let screenShakeX = 0;
let screenShakeY = 0;
let asteroidKills = 0;
let cameraX = CFG.WORLD_W / 2;
let cameraY = CFG.WORLD_H / 2;
let targetCamX = cameraX;
let targetCamY = cameraY;
let camZoom = 0.5;
let targetZoom = 0.5;
let cameraMode = 'overview';
let dogfightPair = null;
let dogfightSwitchCooldown = 0;
let manualShips = [];
let selectBoxStart = null;
let selectBoxEnd = null;
let isSelecting = false;
let cameraLinger = 0;
let cameraTransitioning = false;
let showScoreboard = false;

// Team tracking
let _nextShipUid = 0;

function resizeCanvas() {
  // Fit 9:16 in viewport
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const targetRatio = 9 / 16;
  let cw, ch;
  if (vw / vh > targetRatio) {
    ch = vh;
    cw = vh * targetRatio;
  } else {
    cw = vw;
    ch = vw / targetRatio;
  }
  container.style.width = cw + 'px';
  container.style.height = ch + 'px';
  canvas.width = W = Math.round(cw * devicePixelRatio);
  canvas.height = H = Math.round(ch * devicePixelRatio);
  ctx.scale(devicePixelRatio, devicePixelRatio);
  W = Math.round(cw);
  H = Math.round(ch);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// â”€â”€â”€ INIT (Versus Mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init() {
  ships = [];
  shipById = {};
  _nextShipUid = 0;
  asteroids = [];
  bullets = [];
  particles = [];
  shockwaves = [];
  smokeDecoys = [];
  shipClones = [];
  debrisField = [];
  reflectorShields = [];
  mines = [];
  shipDrones = [];
  orphanTrails = [];
  deathGlows = [];
  incBulletCounter = 0;
  incSpentBullets.clear();
  gameTime = 0;
  gameOver = false;
  winner = null;
  finaleMode = false;
  finaleTimer = 0;
  finaleSlowMo = 1;
  finaleDeath = null;
  finaleFlash = 0;
  screenShakeX = 0;
  screenShakeY = 0;
  asteroidKills = 0;

  // Apply setup settings
  settings.weapons = setupSettings.weapons;
  settings.passives = setupSettings.passives;
  settings.maneuvers = setupSettings.maneuvers;
  settings.randomWeapons = setupSettings.randomLoadouts;
  settings.shipHP = setupSettings.shipHP;

  const isFFA = matchMode === 'ffa';
  const allShipIndices = isFFA ? [...selectedShips] : teams.flat();
  settings.numShips = allShipIndices.length;

  const cx = CFG.WORLD_W / 2;
  const cy = CFG.WORLD_H / 2;

  let drillboreTaken = false;

  if (isFFA) {
    // FFA: spawn in a circle around center, spread out with vertical jitter
    const n = allShipIndices.length;
    const smallMatchMult = n <= 4 ? 1.2 : 1.0; // 20% more spread for small matches
    const radius = Math.min(800, 260 + n * 52) * smallMatchMult;
    for (let si = 0; si < n; si++) {
      const i = allShipIndices[si];
      const ang = (si / n) * Math.PI * 2 - Math.PI / 2;
      const yJitter = rand(-radius * 0.35, radius * 0.35); // semi-random vertical offset
      const sp = { x: cx + Math.cos(ang) * radius + rand(-40, 40), y: cy + Math.sin(ang) * radius + yJitter };
      const faceAng = Math.atan2(cy - sp.y, cx - sp.x); // face center

      ships.push(makeShipObj(i, sp, faceAng, 0));
      applyPassiveBonus(ships[ships.length - 1]);
    }
  } else {
    const numTeams = teams.length;
    const totalFighters = teams.reduce((s, t) => s + t.length, 0);
    const smallMatchMult = totalFighters <= 4 ? 1.2 : 1.0;
    const minTeamSize = Math.min(...teams.map(t => t.length));
    const teamSpread = 200;

    if (numTeams === 2 && minTeamSize < 4) {
      // 2 teams, small: top vs bottom
      const spawnGap = 700 * smallMatchMult;
      for (let ti = 0; ti < 2; ti++) {
        const teamArr = teams[ti];
        const n = teamArr.length;
        const baseY = ti === 0 ? cy - spawnGap : cy + spawnGap;
        const faceAng = ti === 0 ? Math.PI / 2 : -Math.PI / 2;
        for (let si = 0; si < n; si++) {
          const spread = n > 1 ? (si / (n - 1) - 0.5) * teamSpread * Math.min(n, 6) : 0;
          const sp = { x: cx + spread + rand(-40, 40), y: baseY + rand(-50, 50) };
          ships.push(makeShipObj(teamArr[si], sp, faceAng, ti + 1));
          applyPassiveBonus(ships[ships.length - 1]);
        }
      }
    } else if (numTeams === 2) {
      // 2 teams, large: left vs right
      const spawnGap = 700 * smallMatchMult;
      for (let ti = 0; ti < 2; ti++) {
        const teamArr = teams[ti];
        const n = teamArr.length;
        const baseX = ti === 0 ? cx - spawnGap : cx + spawnGap;
        const faceAng = ti === 0 ? 0 : Math.PI;
        for (let si = 0; si < n; si++) {
          const spread = n > 1 ? (si / (n - 1) - 0.5) * teamSpread * Math.min(n, 6) : 0;
          const sp = { x: baseX + rand(-50, 50), y: cy + spread + rand(-40, 40) };
          ships.push(makeShipObj(teamArr[si], sp, faceAng, ti + 1));
          applyPassiveBonus(ships[ships.length - 1]);
        }
      }
    } else {
      // 3+ teams: polygon arrangement â€” each team on a spoke, cloud formation
      const spawnDist = Math.min(900, 500 + totalFighters * 20) * smallMatchMult * 1.2;
      const shipSpacing = 80; // even spacing between ships in cloud
      for (let ti = 0; ti < numTeams; ti++) {
        const teamArr = teams[ti];
        const n = teamArr.length;
        const spokeAng = (ti / numTeams) * Math.PI * 2 - Math.PI / 2;
        const baseX = cx + Math.cos(spokeAng) * spawnDist;
        const baseY = cy + Math.sin(spokeAng) * spawnDist;
        const faceAng = Math.atan2(cy - baseY, cx - baseX); // face center

        // Arrange in a grid cloud centered on base point
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let si = 0; si < n; si++) {
          const col = si % cols;
          const row = Math.floor(si / cols);
          const rowCount = Math.min(cols, n - row * cols);
          const ox = (col - (rowCount - 1) / 2) * shipSpacing;
          const oy = (row - (rows - 1) / 2) * shipSpacing;
          // Rotate grid to face center (perpendicular = across, parallel = depth)
          const perpAng = faceAng + Math.PI / 2;
          const sp = {
            x: baseX + Math.cos(perpAng) * ox + Math.cos(faceAng) * oy + rand(-10, 10),
            y: baseY + Math.sin(perpAng) * ox + Math.sin(faceAng) * oy + rand(-10, 10)
          };
          ships.push(makeShipObj(teamArr[si], sp, faceAng, ti + 1));
          applyPassiveBonus(ships[ships.length - 1]);
        }
      }
    }
  }

  // Prevent early teamkills: for each team, only the ship closest to center can fire immediately
  if (!isFFA) {
    // Store original team sizes for color transition
    _origTeamSizes = [];
    for (let t = 1; t <= teams.length; t++) {
      _origTeamSizes[t] = ships.filter(s => s.team === t).length;
    }
    _teamCoreColors = getTeamColors();
    for (let t = 1; t <= teams.length; t++) {
      const teamShips = ships.filter(s => s.team === t);
      if (teamShips.length <= 1) continue;
      let minDist = Infinity, closestId = null;
      for (const s of teamShips) {
        const d = Math.hypot(s.x - cx, s.y - cy);
        if (d < minDist) { minDist = d; closestId = s.id; }
      }
      for (const s of teamShips) {
        if (s.id !== closestId) s.fireCooldown = 2.0;
      }
    }
  }

  function makeShipObj(i, sp, faceAng, teamNum) {
    const _usePresets = setupSettings.weapons && setupSettings.passives && setupSettings.maneuvers && setupSettings.uniqueShips && !settings.randomPersonalities;
    return {
      id: _nextShipUid++,
      typeId: i,
      name: PILOT_NAMES[i],
      color: PILOT_COLORS[i],
      origColor: PILOT_COLORS[i],
      x: sp.x, y: sp.y,
      vx: 0, vy: 0,
      ang: faceAng,
      r: CFG.SHIP_RADIUS,
      hp: settings.shipHP,
      maxHp: settings.shipHP,
      alive: true,
      fireCooldown: 0,
      invuln: CFG.INVULN_TIME,
      kills: 0,
      deathTime: null,
      placement: 0,
      killedBy: null,
      aiTimer: rand(0, CFG.AI_REACTION),
      aiTarget: null,
      aiEvade: null,
      aiBehavior: _usePresets ? PRESET_PROFILES[i].behavior : randomBehavior(),
      aggroPhase: _usePresets ? PRESET_PROFILES[i].aggroPhase : rand(0, Math.PI * 2),
      aggroSpeed: _usePresets ? PRESET_PROFILES[i].aggroSpeed : rand(0.15, 0.4),
      rockShooter: _usePresets ? PRESET_PROFILES[i].rockShooter : rand(0.1, 0.9),
      aimBaseline: _usePresets ? PRESET_PROFILES[i].aimBaseline : rand(0.3, 0.9),
      aimRange: _usePresets ? PRESET_PROFILES[i].aimRange : rand(0.3, 0.5),
      aimSpeed: _usePresets ? PRESET_PROFILES[i].aimSpeed : rand(0.3, 0.8),
      aimPhase: _usePresets ? PRESET_PROFILES[i].aimPhase : rand(0, Math.PI * 2),
      strafeFuel: 5,
      strafeDepleted: false,
      thrustOn: false,
      weapon: getWeapon(i, teamNum),
      passive: getPassive(i, teamNum),
      shieldActive: false,
      hitInvulnCooldown: 0,
      iceSlow: 0, jamSlow: 0, stunTimer: 0,
      overrideTimer: 0, overrideTurnDir: 0,
      lastAttacker: -1, lastAttackerTime: 0,
      burstQueue: [],
      hpBarTimer: 0,
      beamTrail: [],
      maneuver: getManeuver(i, teamNum),
      maneuverCooldown: rand(3, 8),
      maneuverActive: false,
      maneuverTimer: 0,
      maneuverCount: 0,
      _hyperSpeedActive: false,
      _teleportPhase: null,
      _teleportAng: 0, _teleportShockTimer: 0,
      _rollDir: 0,
      _quickTurnTarget: 0, _quickTurnDone: false,
      _serpDir: 0, _serpSweep: 0, _serpTimer: 0,
      _panicSpinTotal: 0, _panicSpinDone: 0, _panicDir: 0,
      _spinOutPhase: null, _spinOutDir: 0, _spinOutBoostTimer: 0, _spinOutArcTarget: 0,
      _reversePhase: null,
      _smokestealthTimer: 0,
      _reflectorAngle: 0,
      _repulsorX: 0, _repulsorY: 0, _repulsorLife: 0, _repulsorMaxLife: 0, _repulsorRadius: 0,
      _minesDropped: 0, _mineDropTimer: 0,
      _droneWasActive: false,
      _bioRegenTimer: 0,
      blindTimer: 0,
      burnTimer: 0, burnDps: 0, iceDotTimer: 0,
      _bulletThreat: false,
      _emergencyEvade: false,
      team: teamNum,
    };
  }

  function applyPassiveBonus(s) {
    if (s.passive === 'drillbore') {
      if (drillboreTaken) {
        const pool = (!setupSettings.weapons)
          ? PASSIVE_KEYS.filter(k => !ONESHOT_USELESS_PASSIVES.includes(k) && k !== 'drillbore')
          : PASSIVE_KEYS.filter(k => k !== 'drillbore');
        s.passive = pool[randInt(0, pool.length - 1)];
      } else drillboreTaken = true;
    }
    if (s.passive === 'bioHull') { s.hp += 1; s.maxHp += 1; }
    if (s.passive === 'flagship') { s.hp += 7; s.maxHp += 7; s.r *= 2.5; s.maneuver = 'none'; }
    if (s.passive === 'shield') s.shieldActive = true;
    if (s.passive === 'obliterator') s.rockShooter = Math.min(1, s.rockShooter + 0.3);
  }

  shipById = {};
  for (const s of ships) shipById[s.id] = s;

  // Build team color palettes for team trail particles
  teamPalettes = {};
  for (const s of ships) {
    if (s.team > 0) {
      if (!teamPalettes[s.team]) teamPalettes[s.team] = [];
      if (!teamPalettes[s.team].includes(s.color)) teamPalettes[s.team].push(s.color);
    }
  }

  // Spawn asteroids - fewer for smaller world
  const numMegas = randInt(0, 2);
  for (let i = 0; i < numMegas; i++) {
    let ast, tries = 0;
    do { ast = spawnAsteroid(0); tries++; } while (tries < 20 && ships.some(s => dist(s, ast) < 400));
    asteroids.push(ast);
  }
  for (let i = 0; i < CFG.NUM_ASTEROIDS; i++) {
    let ast, tries = 0;
    const sizeIdx = Math.random() < 0.1 ? 2 : 1;
    do { ast = spawnAsteroid(sizeIdx); tries++; } while (tries < 20 && ships.some(s => dist(s, ast) < 200));
    asteroids.push(ast);
  }
  // Border asteroids
  const border = 400;
  for (let i = 0; i < 30; i++) {
    const side = randInt(0, 3);
    let bx, by;
    if (side === 0) { bx = rand(-border, 0); by = rand(-border, CFG.WORLD_H + border); }
    else if (side === 1) { bx = rand(CFG.WORLD_W, CFG.WORLD_W + border); by = rand(-border, CFG.WORLD_H + border); }
    else if (side === 2) { bx = rand(-border, CFG.WORLD_W + border); by = rand(-border, 0); }
    else { bx = rand(-border, CFG.WORLD_W + border); by = rand(CFG.WORLD_H, CFG.WORLD_H + border); }
    const sizeIdx = Math.random() < 0.15 ? 0 : Math.random() < 0.3 ? 2 : 1;
    const bAst = spawnAsteroid(sizeIdx, bx, by);
    bAst.isBorder = true;
    bAst.vx *= 0.2; bAst.vy *= 0.2;
    asteroids.push(bAst);
  }

  // Compute initial camera to frame all ships
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const s of ships) {
    minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
    minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
  }
  const pad = 400 + ships.length * 30;
  cameraX = (minX + maxX) / 2;
  cameraY = (minY + maxY) / 2;
  const spreadX = maxX - minX + pad;
  const spreadY = maxY - minY + pad;
  const initZoom = Math.max(0.15, Math.min(1.5, Math.min(W / spreadX, H / spreadY)));
  camZoom = initZoom;
  targetZoom = initZoom;
  _camTargetSmX = cameraX;
  _camTargetSmY = cameraY;
  _camTargetSmZ = initZoom;
  cameraMode = 'overview';
  dogfightPair = null;
  dogfightSwitchCooldown = 0;
  manualShips = [];
}
// â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnExplosion(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, speed);
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: rand(0.3, 1.2),
      maxLife: 1.2,
      color,
      size: rand(1, 3),
    });
  }
  shockwaves.push({ x, y, r: 0, maxR: speed * 0.8, life: 0.4, color });
}

function spawnThrustParticle(ship) {
  const bx = ship.x - Math.cos(ship.ang) * ship.r * 0.5;
  const by = ship.y - Math.sin(ship.ang) * ship.r * 0.5;
  const lifeMult = (ship.passive === 'nitro' ? 2.0 : 1.0) * (ship.team > 0 ? 3.0 : 1.0);

  if (ship.passive === 'stealth') {
    // Beam trail: store position for line drawing instead of particles
    if (!ship.beamTrail) ship.beamTrail = [];
    ship.beamTrail.push({ x: bx, y: by, life: 0.25 * lifeMult, maxLife: 0.25 * lifeMult });
    return;
  }

  // Determine exhaust angles: center for normal, center + Â±30Â° for gyro
  const angles = [ship.ang + Math.PI]; // default: straight back
  if (ship.passive === 'gyro') {
    angles.push(ship.ang + Math.PI + 0.524); // +30Â°
    angles.push(ship.ang + Math.PI - 0.524); // -30Â°
  }

  for (const exAng of angles) {
    const isBio = ship.passive === 'bioHull';
    particles.push({
      x: bx + rand(-3, 3),
      y: by + rand(-3, 3),
      vx: Math.cos(exAng) * rand(30, 80) + ship.vx * 0.3,
      vy: Math.sin(exAng) * rand(30, 80) + ship.vy * 0.3,
      life: rand(0.1, 0.3) * lifeMult,
      maxLife: 0.3 * lifeMult,
      color: isBio ? '#44ff44' : trailColor(ship),
      size: rand(1, 2.5),
      isPlus: isBio,
    });
  }
}

// â”€â”€â”€ AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Predict if a ship will collide with an asteroid within `lookahead` seconds
function predictCollision(ship, ast, lookahead) {
  // Relative velocity
  const rvx = ship.vx - ast.vx;
  const rvy = ship.vy - ast.vy;
  // Relative position
  const rpx = ship.x - ast.x;
  const rpy = ship.y - ast.y;
  // Closest approach time: t = -dot(rp,rv) / dot(rv,rv)
  const rvDot = rvx * rvx + rvy * rvy;
  if (rvDot < 1) return null; // barely moving relative
  const t = -(rpx * rvx + rpy * rvy) / rvDot;
  if (t < 0 || t > lookahead) return null;
  // Distance at closest approach
  const cx = rpx + rvx * t;
  const cy = rpy + rvy * t;
  const closestDist = Math.hypot(cx, cy);
  const collisionR = ship.r + ast.r * 0.85 + 40; // generous safety margin
  if (closestDist < collisionR) {
    return { t, dist: closestDist, ast };
  }
  return null;
}

// Check if a direction is safe â€” no asteroid collisions along that path
function isDirectionSafe(ship, ang, speed, lookahead) {
  const testVx = Math.cos(ang) * speed;
  const testVy = Math.sin(ang) * speed;
  const testShip = { x: ship.x, y: ship.y, vx: testVx, vy: testVy, r: ship.r };
  const scanR = 400 + speed * lookahead; // scale scan with how far we'll travel
  for (const ast of asteroids) {
    const d = dist(ship, ast);
    if (d > scanR) continue;
    if (predictCollision(testShip, ast, lookahead)) return false;
  }
  return true;
}

// Find the best evasion angle â€” scan multiple directions and pick the safest
function findSafeDirection(ship, preferredAng, speed, look) {
  if (ship.passive === 'drillbore' && ship.hp > 0.5) return preferredAng;
  const la = look || 1.5;
  // Test preferred angle first
  if (isDirectionSafe(ship, preferredAng, speed, la)) return preferredAng;
  // Fan out from preferred angle
  for (let offset = 0.3; offset <= Math.PI; offset += 0.25) {
    if (isDirectionSafe(ship, preferredAng + offset, speed, la)) return preferredAng + offset;
    if (isDirectionSafe(ship, preferredAng - offset, speed, la)) return preferredAng - offset;
  }
  // Nothing safe â€” go opposite of densest threat cluster
  return preferredAng + Math.PI;
}

function updateAI(ship, dt) {
  ship.aiTimer -= dt;
  if (ship.aiTimer > 0) return;
  ship.aiTimer = CFG.AI_REACTION + rand(0, 0.08);
  ship._isStrafing = false;
  ship._avoidStrafe = false;
  ship._avoidStrafeStrength = 1;
  ship._bloodthirstyCombat = false;

  let closestEnemy = null;
  let closestEnemyDist = Infinity;
  const shipSpeed = Math.hypot(ship.vx, ship.vy);

  // â”€â”€ PREDICTIVE ASTEROID COLLISION SCAN â”€â”€
  // Gather all imminent collisions within the next 2 seconds
  const collisions = [];
  if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
    for (const ast of asteroids) {
      const d = dist(ship, ast);
      if (d > 900) continue; // scan wider radius
      const col = predictCollision(ship, ast, 3.0);
      if (col) collisions.push(col);
    }
    // Sort by urgency (soonest first)
    collisions.sort((a, b) => a.t - b.t);
  }

  // â”€â”€ SCAN INCOMING BULLETS â”€â”€
  let bulletThreat = null;
  for (const b of bullets) {
    if (b.owner === ship.id) continue;
    if (b.ownerTeam > 0 && ship.team === b.ownerTeam) continue;
    const d = dist(ship, b);
    if (d > 200) continue;
    // Is bullet heading toward us?
    const toShipX = ship.x - b.x;
    const toShipY = ship.y - b.y;
    const dot = toShipX * b.vx + toShipY * b.vy;
    if (dot > 0) { // bullet moving toward ship
      const bSpeed = Math.hypot(b.vx, b.vy);
      const timeToHit = d / bSpeed;
      if (timeToHit < 0.5 && (!bulletThreat || timeToHit < bulletThreat.time)) {
        bulletThreat = { obj: b, time: timeToHit, dist: d };
      }
    }
  }

  // â”€â”€ SCAN ENEMIES â”€â”€
  for (const other of ships) {
    if (other.id === ship.id || !other.alive) continue;
    // Skip teammates in team mode
    if (ship.team > 0 && other.team === ship.team) continue;
    let d = dist(ship, other);
    // Stealth passive: target appears twice as far away
    if (other.passive === 'stealth') d *= 1.5;
    // Smokescreen: extreme stealth â€” 96% shrink for 2s, decaying over next 3s
    if (other._smokestealthTimer > 0) {
      const st = other._smokestealthTimer;
      if (st > 3.0) {
        d *= 25; // full 96% detection shrink
      } else {
        d *= 1 + 24 * (st / 3.0); // decay from 25x back to 1x
      }
    }
    // Blinding rounds: this ship is blinded â€” can't see enemies
    if (ship.blindTimer > 0) {
      if (ship.blindTimer > 1.5) {
        d = Infinity; // fully blind
      } else {
        d *= 1 + 50 * (ship.blindTimer / 1.5); // decay from 51x to 1x
      }
    }
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      closestEnemy = other;
    }
  }

  // Check smoke decoys as potential targets (stationary fake enemy)
  for (const decoy of smokeDecoys) {
    if (decoy.ownerId === ship.id) continue; // don't target own smoke
    const d = dist(ship, decoy);
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      closestEnemy = { x: decoy.x, y: decoy.y, vx: 0, vy: 0, id: -99, alive: true };
    }
  }

  // Check ship clones as potential targets (Double Team)
  for (const clone of shipClones) {
    if (clone.ownerId === ship.id || !clone.alive || clone.hit) continue;
    const d = dist(ship, clone);
    if (d < closestEnemyDist) {
      closestEnemyDist = d;
      const parent = shipById[clone.ownerId];
      closestEnemy = { x: clone.x, y: clone.y, vx: parent ? parent.vx : 0, vy: parent ? parent.vy : 0, id: -98, alive: true };
    }
  }

  // â”€â”€ BORDER AVOIDANCE â”€â”€
  const margin = 250;
  let borderForceX = 0, borderForceY = 0;
  const borderStrength = 1.5;
  if (ship.x < margin) borderForceX = borderStrength * (1 - ship.x / margin);
  if (ship.x > CFG.WORLD_W - margin) borderForceX = -borderStrength * (1 - (CFG.WORLD_W - ship.x) / margin);
  if (ship.y < margin) borderForceY = borderStrength * (1 - ship.y / margin);
  if (ship.y > CFG.WORLD_H - margin) borderForceY = -borderStrength * (1 - (CFG.WORLD_H - ship.y) / margin);
  const hasBorderPressure = Math.abs(borderForceX) > 0.1 || Math.abs(borderForceY) > 0.1;

  // â”€â”€ DECIDE BEHAVIOR (PRIORITY SYSTEM) â”€â”€
  let desiredAng = ship.ang;
  let wantThrust = false;
  let wantShoot = false;

  // Bloodthirsty check: if engaging an enemy, skip asteroid avoidance entirely
  // Bloodthirsty check: reckless only if target isn't firing back
  let bloodthirstyInCombat = false;
  if (ship.aiBehavior === 'bloodthirsty' && closestEnemy && closestEnemyDist < 1400) {
    // As the match progresses, bloodthirsty cares less about return fire
    // bloodthirstyRage: 0.35 at start â†’ 1 by ~90s (reckless from the beginning, fully unhinged late)
    const bloodthirstyRage = Math.min(1, 0.35 + gameTime / 120);
    // Check if the target has any bullets heading our way
    let targetFiringBack = false;
    for (const b of bullets) {
      if (b.owner !== closestEnemy.id) continue;
      const d = dist(ship, b);
      if (d > 500) continue;
      const dot = (ship.x - b.x) * b.vx + (ship.y - b.y) * b.vy;
      if (dot > 0) { targetFiringBack = true; break; }
    }
    // Early game: only reckless vs passive targets. Late game: reckless regardless.
    bloodthirstyInCombat = !targetFiringBack || Math.random() < bloodthirstyRage;
  }

  // PRIORITY 1: Imminent asteroid collision (< 1s away) â€” bloodthirsty now dodges rocks but ignores bullets
  const urgentCollision = collisions.length > 0 && collisions[0].t < 1.0;

  // PRIORITY 2: Bullet dodge
  const urgentBullet = bulletThreat && bulletThreat.time < 0.4;

  if (urgentCollision || (urgentBullet && !bloodthirstyInCombat)) {
    // Build a combined avoidance vector from all imminent threats
    let avoidX = 0, avoidY = 0;
    const strafeDir = (ship.typeId % 2 === 0) ? 1 : -1;

    for (const col of collisions) {
      if (col.t > 1.5) break;
      const urgency = 1 / (col.t + 0.1);
      const toAst = angle(ship, col.ast);
      // Asteroids are weighted 3x â€” dodging into a rock is always worse than eating a bullet
      const slipAng = toAst + Math.PI * 0.8 + strafeDir * 0.4;
      avoidX += Math.cos(slipAng) * urgency * 3;
      avoidY += Math.sin(slipAng) * urgency * 3;
    }

    if (bulletThreat) {
      const toBullet = angle(ship, bulletThreat.obj);
      const urgency = 1 / (bulletThreat.time + 0.05);
      const slipAng = toBullet + Math.PI * 0.5 * strafeDir;
      // Only dodge bullet if there are no nearby asteroid collisions
      const bulletWeight = collisions.length > 0 ? 0.15 : 0.8;
      avoidX += Math.cos(slipAng) * urgency * bulletWeight;
      avoidY += Math.sin(slipAng) * urgency * bulletWeight;
    }

    if (hasBorderPressure) {
      avoidX += borderForceX * 2;
      avoidY += borderForceY * 2;
    }

    if (Math.abs(avoidX) > 0.01 || Math.abs(avoidY) > 0.01) {
      const rawAvoidAng = Math.atan2(avoidY, avoidX);
      desiredAng = findSafeDirection(ship, rawAvoidAng, Math.max(shipSpeed, 120));
    } else {
      // Perpendicular escape with strafe bias
      const threat = collisions[0] || { ast: bulletThreat.obj };
      const toThreat = angle(ship, threat.ast || bulletThreat.obj);
      desiredAng = toThreat + Math.PI * 0.5 * strafeDir;
    }
    wantThrust = true;
    // Flag lateral push for smooth per-frame strafe
    ship._avoidStrafe = true;

    // Opportunistic shooting at the asteroid blocking us
    if (urgentCollision) {
      const toAst = angle(ship, collisions[0].ast);
      const da = Math.abs(shortAngleDist(ship.ang, toAst));
      if (da < 0.4 && Math.random() < ship.rockShooter) wantShoot = true;
    }
  }
  // PRIORITY 3: Border avoidance
  else if (hasBorderPressure) {
    const borderAng = Math.atan2(borderForceY, borderForceX);
    desiredAng = findSafeDirection(ship, borderAng, Math.max(shipSpeed, 100));
    wantThrust = true;
  }
  // PRIORITY 4: Upcoming collision (1-2.5s) â€” gentle strafe correction (bloodthirsty ignores when in combat)
  else if (collisions.length > 0 && collisions[0].t < 2.5 && !bloodthirstyInCombat) {
    const col = collisions[0];
    const toAst = angle(ship, col.ast);
    const strafeDir = (ship.typeId % 2 === 0) ? 1 : -1;
    // Gentle lateral offset â€” weave past rather than hard turn
    // Blend current heading with a perpendicular nudge
    const perpAng = toAst + Math.PI * 0.5 * strafeDir;
    const urgencyBlend = Math.max(0.2, Math.min(0.7, 1 - col.t / 2.5));
    const weaveAng = ship.ang + shortAngleDist(ship.ang, perpAng) * urgencyBlend;
    desiredAng = findSafeDirection(ship, weaveAng, Math.max(shipSpeed, 100));
    wantThrust = true;
    ship._avoidStrafe = true;
    ship._avoidStrafeStrength = urgencyBlend; // stronger as collision gets closer

    // Try to shoot the asteroid if we can
    const da = Math.abs(shortAngleDist(ship.ang, toAst));
    if (da < 0.35 && Math.random() < ship.rockShooter) wantShoot = true;
  }
  // PRIORITY 5: Combat
  else if (closestEnemy) {
    // Aggression oscillation â€” each ship periodically surges toward more aggressive behavior
    const aliveCount = ships.filter(s => s.alive).length;
    // Evasive ships shift to hunter-level aggression in top 3 â€” survival instinct kicks in
    const evasiveEndgame = ship.aiBehavior === 'evasive' && aliveCount <= 3;
    const aggroBase = ship.aiBehavior === 'aggressive' || ship.aiBehavior === 'bloodthirsty' ? 0.85 :
                      ship.aiBehavior === 'hunter' || evasiveEndgame ? 0.6 :
                      ship.aiBehavior === 'cautious' ? 0.35 : 0.2;
    const aggroSwing = ship.aiBehavior === 'aggressive' || ship.aiBehavior === 'bloodthirsty' ? 0.15 :
                       ship.aiBehavior === 'hunter' || evasiveEndgame ? 0.25 :
                       ship.aiBehavior === 'cautious' ? 0.3 : 0.35;
    const aggro = Math.max(0, Math.min(1, aggroBase + Math.sin(gameTime * ship.aggroSpeed + ship.aggroPhase) * aggroSwing));

    // Interpolate personality values toward aggressive levels based on aggro
    const teamDetectMult = (ship.team > 0) ? 3 : 1;
    const baseRange = lerp(550, 1400, aggro) * teamDetectMult;
    const maxRange = Math.hypot(CFG.WORLD_W, CFG.WORLD_H);
    const timeScale = Math.min(1, gameTime / 60);
    const aggressionRange = lerp(baseRange, maxRange, timeScale);

    if (closestEnemyDist < aggressionRange) {
      if (ship.aiBehavior === 'bloodthirsty') ship._bloodthirstyCombat = bloodthirstyInCombat;
      const toEnemy = angle(ship, closestEnemy);
      const wSpeed = ship.weapon.speed;
      const travelTime = closestEnemyDist / wSpeed;
      // Oscillating lead factor â€” smoothly drifts between direct and leading shots
      const rawLead = ship.aimBaseline + Math.sin(gameTime * ship.aimSpeed + ship.aimPhase) * ship.aimRange;
      // Turret Mode or Spin Out boost: clamp aim toward optimal leading
      const hasAimBoost = (ship.maneuverActive && ship.maneuver === 'turretMode') || ship._spinOutBoostTimer > 0;
      const leadFactor = hasAimBoost
        ? Math.max(0.7, Math.min(1.1, rawLead))
        : Math.max(0.05, Math.min(1.3, rawLead));
      const leadX = closestEnemy.x + closestEnemy.vx * travelTime * leadFactor;
      const leadY = closestEnemy.y + closestEnemy.vy * travelTime * leadFactor;
      const leadAng = Math.atan2(leadY - ship.y, leadX - ship.x);

      // Evasive flee â€” only when aggro is low enough (bloodthirsty never flees when reckless)
      // In top 3, evasive ships stop running and fight
      // Drone users keep their distance when drones are orbiting
      const hasDronesOut = ship.weapon.type === 'drone' && shipDrones.some(d => d.ownerId === ship.id);
      const droneFleeBonus = hasDronesOut ? 350 : 0;
      const fleeThreshold = ((ship.aiBehavior === 'evasive' && !evasiveEndgame) ? 300 : 150) + droneFleeBonus;
      const fleeAggroThreshold = hasDronesOut ? 0.7 : 0.4;
      if (!(ship.aiBehavior === 'bloodthirsty' && bloodthirstyInCombat) && aggro < fleeAggroThreshold && closestEnemyDist < fleeThreshold) {
        const fleeAng = toEnemy + Math.PI;
        desiredAng = findSafeDirection(ship, fleeAng, Math.max(shipSpeed, 120));
        wantThrust = true;
      } else {
        // Separate flight path from aim â€” approach at a slight offset to create lateral movement
        const strafeDir = (ship.typeId % 2 === 0) ? 1 : -1;
        const baseStrafeAng = lerp(0.4, 0.12, aggro);
        // Strafe starts gentle from far away, increases as they close in
        const strafeFactor = Math.max(0.15, Math.min(1, 1 - (closestEnemyDist - 300) / 1500));
        
        // Only strafe if we have fuel
        const canStrafe = !ship.strafeDepleted && ship.strafeFuel > 0;
        const strafeOffset = canStrafe ? baseStrafeAng * strafeFactor * strafeDir : 0;
        ship._isStrafing = canStrafe && closestEnemyDist < 1000;

        const flightAng = toEnemy + strafeOffset;
        const approachAng = closestEnemyDist > 350 ?
          findSafeDirection(ship, flightAng, Math.max(shipSpeed, 100)) : flightAng;
        
        // Safety check: if our combat path leads into an asteroid, override with evasion
        // Bloodthirsty ignores this when target isn't firing back
        let combatAng = approachAng;
        if (!(ship.aiBehavior === 'bloodthirsty' && bloodthirstyInCombat)) {
          for (const col of collisions) {
            if (col.t < 1.5) {
              const toAst = angle(ship, col.ast);
              const awayAng = toAst + Math.PI;
              const blend = Math.max(0.3, Math.min(0.8, 1 - col.t / 1.5));
              combatAng = combatAng + shortAngleDist(combatAng, awayAng) * blend;
              break;
            }
          }
        }
        desiredAng = combatAng;
        wantThrust = closestEnemyDist > 150;
        const da = Math.abs(shortAngleDist(ship.ang, leadAng));
        const bulletRange = ship.weapon.speed * ship.weapon.life;
        const fireRangeMult = lerp(0.75, 1.2, aggro);
        const aimCone = ship.weapon.type === 'homing' ? 0.6 :
                        ship.weapon.type === 'shotgun' || ship.weapon.type === 'flamethrower' ? 0.45 : 0.35;
        wantShoot = da < aimCone && closestEnemyDist < bulletRange * fireRangeMult;
      }
    } else {
      // Roam â€” head toward center-ish via safe path
      const toCenterAng = Math.atan2(CFG.WORLD_H/2 - ship.y, CFG.WORLD_W/2 - ship.x);
      const toCenterDist = Math.hypot(CFG.WORLD_W/2 - ship.x, CFG.WORLD_H/2 - ship.y);
      const roamThreshold = lerp(2500, 800, Math.min(1, gameTime / 60));
      const roamAng = toCenterDist > roamThreshold ? toCenterAng + rand(-0.4, 0.4) : ship.ang + rand(-0.6, 0.6);
      desiredAng = findSafeDirection(ship, roamAng, Math.max(shipSpeed, 80), 2.5);
      wantThrust = true;
    }
  } else {
    // No enemies â€” just roam safely
    desiredAng = findSafeDirection(ship, ship.ang + rand(-0.4, 0.4), Math.max(shipSpeed, 80), 2.5);
    wantThrust = true;
  }

  // â”€â”€ APPLY AI INTENT â”€â”€
  const turnDir = shortAngleDist(ship.ang, desiredAng);
  ship._aiTurnDir = Math.sign(turnDir) * Math.min(1, Math.abs(turnDir) * 3);
  ship._aiThrust = wantThrust;
  ship._aiShoot = wantShoot;

  // â”€â”€ MANEUVER CONTEXT FLAGS â”€â”€
  ship._bulletThreat = !!bulletThreat;
  ship._emergencyEvade = collisions.length > 0;

  // â”€â”€ MANEUVER TRIGGER CHECK â”€â”€
  if (ship.maneuver !== 'none' && !ship.maneuverActive && ship.maneuverCooldown <= 0) {
    if (checkManeuverTrigger(ship)) {
      startManeuver(ship);
      ship.maneuverCount++;
    }
  }
}

// â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(rawDt) {
  const dt = rawDt * simSpeed * finaleSlowMo * 0.5;

  if (pregame) {
    targetCamX = CFG.WORLD_W / 2;
    targetCamY = CFG.WORLD_H / 2;
    const fullZoomX = W / (CFG.WORLD_W + 200);
    const fullZoomY = H / (CFG.WORLD_H + 200);
    targetZoom = Math.min(fullZoomX, fullZoomY);
    const camLerpPre = 1 - Math.pow(1 - 0.05, rawDt * 60);
    cameraX = lerp(cameraX, targetCamX, camLerpPre);
    cameraY = lerp(cameraY, targetCamY, camLerpPre);
    camZoom = lerp(camZoom, targetZoom, camLerpPre);
    return;
  }

  if (countdown) {
    countdownTimer -= rawDt;
    const secs = Math.ceil(Math.max(0, countdownTimer));
    const timerEl = document.getElementById('cd-timer');
    if (secs > 0) {
      const modeLabel = matchMode === 'ffa' ? 'Battle Royale' : 'Team Battle';
      timerEl.textContent = `${modeLabel} begins in: ${secs}...`;
    } else {
      timerEl.textContent = 'FIGHT!';
    }
    // Camera stays framed on ships during countdown
    if (!finaleMode) updateCamera(0, rawDt);
    if (countdownTimer <= 0) {
      countdown = false;
      countdownTimer = 0;
      document.getElementById('countdown-overlay').classList.add('hidden');
      document.getElementById('match-hud').classList.add('active');
      showScoreboard = true;
    }
    return;
  }

  if (gameOver && !finaleMode) return;
  const skipGameplay = gameOver;
  gameTime += dt;

  if (!skipGameplay) {

  // Team color transition: ships shift to team core color as teammates die
  if (matchMode === 'teams' && _origTeamSizes.length > 0) {
    const _aliveCounts = [];
    for (const s of ships) if (s.alive && s.team > 0) _aliveCounts[s.team] = (_aliveCounts[s.team] || 0) + 1;
    for (const ship of ships) {
      if (!ship.alive || ship.team <= 0) continue;
      const orig = _origTeamSizes[ship.team] || 1;
      const deadRatio = (orig - (_aliveCounts[ship.team] || 0)) / Math.max(1, orig);
      const t = Math.min(1, deadRatio / 0.5);
      ship.color = t > 0.01 ? lerpHexColor(ship.origColor, _teamCoreColors[ship.team - 1], t) : ship.origColor;
    }
  }

  // Update ships
  for (const ship of ships) {
    if (!ship.alive) continue;

    ship.invuln = Math.max(0, ship.invuln - dt);
    ship.hitInvulnCooldown = Math.max(0, ship.hitInvulnCooldown - dt);
    ship.iceSlow = Math.max(0, ship.iceSlow - dt);
    ship.jamSlow = Math.max(0, ship.jamSlow - dt);
    ship.stunTimer = Math.max(0, ship.stunTimer - dt);
    ship.blindTimer = Math.max(0, ship.blindTimer - dt);

    // Incendiary burn DoT
    if (ship.burnTimer > 0) {
      ship.hp -= ship.burnDps * dt;
      ship.burnTimer -= dt;
      ship.hpBarTimer = 0.3;
      if (ship.burnTimer <= 0) { ship.burnTimer = 0; ship.burnDps = 0; }
      if (ship.hp <= 0 && ship.alive) killShip(ship, ship.lastAttacker);
    }
    // Ice rounds DoT: 0.25 HP over 2s
    if (ship.iceDotTimer > 0) {
      ship.hp -= (0.25 / 2.0) * dt;
      ship.iceDotTimer -= dt;
      ship.hpBarTimer = 0.3;
      if (ship.iceDotTimer <= 0) ship.iceDotTimer = 0;
      if (ship.hp <= 0 && ship.alive) killShip(ship, ship.lastAttacker);
    }

    // Bio-Hull regeneration: +0.1 HP every 2 seconds
    if (ship.passive === 'bioHull' && ship.hp < ship.maxHp) {
      ship._bioRegenTimer += dt;
      if (ship._bioRegenTimer >= 2.0) {
        ship._bioRegenTimer -= 2.0;
        ship.hp = Math.min(ship.maxHp, ship.hp + 0.1);
        // Plus sign particle
        particles.push({
          x: ship.x + rand(-8, 8), y: ship.y + rand(-8, 8),
          vx: rand(-10, 10), vy: rand(-30, -15),
          life: 0.8, maxLife: 0.8, color: '#44ff44', size: 4,
          isPlus: true,
        });
      }
    }
    ship.overrideTimer = Math.max(0, ship.overrideTimer - dt);

    // Age stealth beam trail
    if (ship.beamTrail) {
      for (let t = ship.beamTrail.length - 1; t >= 0; t--) {
        ship.beamTrail[t].life -= dt;
        if (ship.beamTrail[t].life <= 0) ship.beamTrail.splice(t, 1);
      }
    }

    // â”€â”€ DEBUFF VISUAL EFFECTS â”€â”€
    // Incendiary burn: fire particles rising from ship
    if (ship.burnTimer > 0 && Math.random() < 0.5) {
      particles.push({
        x: ship.x + rand(-ship.r, ship.r), y: ship.y + rand(-ship.r, ship.r),
        vx: rand(-20, 20), vy: rand(-60, -30),
        life: rand(0.2, 0.4), maxLife: 0.4,
        color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00', size: rand(2, 4),
      });
    }
    // Ice Rounds: diamond and snowflake particles emitted from affected ship
    if (ship.iceSlow > 0 && Math.random() < 0.4) {
      const perp = ship.ang + Math.PI / 2;
      const side = Math.random() < 0.5 ? 1 : -1;
      const offset = rand(0, ship.r * 1.2);
      const iceType = Math.random() < 0.5 ? 'diamond' : 'snowflake';
      particles.push({
        x: ship.x + Math.cos(perp) * side * offset, y: ship.y + Math.sin(perp) * side * offset,
        vx: Math.cos(perp) * side * rand(30, 60) + rand(-10, 10),
        vy: Math.sin(perp) * side * rand(30, 60) + rand(-10, 10) - 15,
        life: 0.4, maxLife: 0.4,
        color: '#55bbff', size: rand(3, 6),
        isDiamond: iceType === 'diamond', isSnowflake: iceType === 'snowflake',
        spinAng: rand(0, Math.PI * 2),
      });
    }

    // Jam Rounds: perpendicular lines from front of affected ship
    if (ship.jamSlow > 0 && Math.random() < 0.35) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      const perp = ship.ang + Math.PI / 2;
      const side = Math.random() < 0.5 ? 1 : -1;
      particles.push({
        x: fx, y: fy,
        vx: Math.cos(perp) * side * rand(30, 70),
        vy: Math.sin(perp) * side * rand(30, 70),
        life: 0.25, maxLife: 0.25,
        color: '#ffaa00', size: rand(1.5, 3), isLine: true, lineAng: perp, lineLen: rand(6, 12),
      });
    }

    // Stun Shock: mini lightning arcs crackle on affected ship
    if (ship.stunTimer > 0 && Math.random() < 0.4) {
      const a = rand(0, Math.PI * 2);
      const d = rand(0, ship.r * 1.2);
      const arcLen = rand(8, 18);
      const segs = randInt(2, 3);
      const ap = [{x: 0, y: 0}];
      for (let s = 1; s <= segs; s++) {
        const t = s / segs;
        ap.push({
          x: Math.cos(a) * arcLen * t + rand(-4, 4),
          y: Math.sin(a) * arcLen * t + rand(-4, 4)
        });
      }
      particles.push({
        x: ship.x + Math.cos(a) * d, y: ship.y + Math.sin(a) * d,
        vx: rand(-20, 20), vy: rand(-20, 20),
        life: 0.18, maxLife: 0.18,
        color: '#ffff44', size: 1.5,
        isArc: true, arcPoints: ap,
      });
    }

    // Override: ball particles from front of affected ship
    if (ship.overrideTimer > 0 && Math.random() < 0.5) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r;
      const fy = ship.y + Math.sin(ship.ang) * ship.r;
      const a = rand(0, Math.PI * 2);
      particles.push({
        x: fx + rand(-5, 5), y: fy + rand(-5, 5),
        vx: Math.cos(a) * rand(20, 60), vy: Math.sin(a) * rand(20, 60),
        life: 0.25, maxLife: 0.25,
        color: '#8844dd', size: rand(2, 4.5),
      });
    }

    // Blinding rounds: orange ellipse flashes in front of affected ship
    if (ship.blindTimer > 0 && Math.random() < 0.4) {
      const fx = ship.x + Math.cos(ship.ang) * ship.r * 1.2;
      const fy = ship.y + Math.sin(ship.ang) * ship.r * 1.2;
      shockwaves.push({
        x: fx + rand(-6, 6), y: fy + rand(-6, 6),
        r: 0, maxR: rand(12, 25), life: 0.2, maxLife: 0.2,
        color: '#ff8800', ellipse: true, ellipseAng: ship.ang + rand(-0.3, 0.3),
      });
    }
    ship.fireCooldown = Math.max(0, ship.fireCooldown - dt);
    ship.hpBarTimer = Math.max(0, ship.hpBarTimer - dt);

    // AI
    updateAI(ship, dt);

    // Maneuver cooldown & update
    ship.maneuverCooldown = Math.max(0, ship.maneuverCooldown - dt);
    if (ship._spinOutBoostTimer > 0) ship._spinOutBoostTimer = Math.max(0, ship._spinOutBoostTimer - dt);
    if (ship._smokestealthTimer > 0) ship._smokestealthTimer = Math.max(0, ship._smokestealthTimer - dt);
    updateManeuver(ship, dt);

    // Strafe fuel management
    if (ship._isStrafing) {
      ship.strafeFuel = Math.max(0, ship.strafeFuel - dt);
      if (ship.strafeFuel <= 0) {
        ship.strafeDepleted = true;
      }
    } else {
      if (ship.strafeDepleted) {
        ship.strafeFuel = Math.min(5, ship.strafeFuel + dt);
        if (ship.strafeFuel >= 5) ship.strafeDepleted = false;
      } else {
        ship.strafeFuel = Math.min(5, ship.strafeFuel + dt * 1.0);
      }
    }

    // Active maneuver overrides normal movement (barrel roll, quick-turn, teleport)
    const maneuverControlsMovement = ship.maneuverActive &&
      (ship.maneuver === 'barrelRoll' || ship.maneuver === 'quickTurn' || ship._teleportPhase === 'phasing'
       || ship.maneuver === 'serpentine' || ship.maneuver === 'panic'
       || ship.maneuver === 'spinOut');

    // Override rounds: hijack controls â€” forced thrust + random turn
    if (ship.overrideTimer > 0 && !maneuverControlsMovement) {
      ship.ang += ship.overrideTurnDir * CFG.SHIP_TURN_SPEED * dt;
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * dt;
      ship.thrustOn = true;
    }

    // Turn (gatling reduces turn speed by 60% while firing)
    const gatlingFiring = ship.weapon.type === 'gatling' && ship.burstQueue.length > 0;
    const gyroMult = ship.passive === 'gyro' ? 1.3 : 1.0;
    const turnSpeedMult = (gatlingFiring ? 0.2 : 1.0) * gyroMult * (ship.stunTimer > 1.25 ? 0 : ship.stunTimer > 0 ? 1 - ship.stunTimer / 1.25 : 1);
    if (ship.overrideTimer <= 0 && !maneuverControlsMovement) {
      ship.ang += (ship._aiTurnDir || 0) * CFG.SHIP_TURN_SPEED * turnSpeedMult * dt;
    }

    // FRAME-LEVEL EMERGENCY: check for imminent asteroid collision every frame
    // Uses lateral thrust to slip past rather than hard turning
    let emergency = false;
    if (ship.overrideTimer <= 0 && !maneuverControlsMovement) {
    let emergAvoidX = 0, emergAvoidY = 0;
    let emergCount = 0;
    if (ship.passive !== 'drillbore' || ship.hp <= 0.5) {
      for (const ast of asteroids) {
        const d = dist(ship, ast);
        if (d > ast.r + 350) continue;
        const col = predictCollision(ship, ast, 1.0);
        if (col) {
          const toAst = angle(ship, ast);
          const urgency = 1 / (col.t + 0.05);
          emergAvoidX -= Math.cos(toAst) * urgency;
          emergAvoidY -= Math.sin(toAst) * urgency;
          emergCount++;
        }
      }
    }
    if (emergCount > 0) {
      emergency = true;
      const escapeAng = Math.atan2(emergAvoidY, emergAvoidX);
      const btRage = ship._bloodthirstyCombat ? Math.min(1, 0.35 + gameTime / 120) : 0;
      const turnMult = ship._bloodthirstyCombat ? lerp(0.45, 0.25, btRage) : 1.5;
      const turnNeeded = shortAngleDist(ship.ang, escapeAng);
      ship.ang += Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), CFG.SHIP_TURN_SPEED * turnMult * turnSpeedMult * dt);
      const strafeDir = (ship.typeId % 2 === 0) ? 1 : -1;
      const perpAng = ship.ang + Math.PI * 0.5 * strafeDir;
      const strafeForce = CFG.SHIP_THRUST * 0.35;
      ship.vx += Math.cos(perpAng) * strafeForce * dt;
      ship.vy += Math.sin(perpAng) * strafeForce * dt;
      ship._aiThrust = true;
    }

    // AI-level avoidance strafe
    if (!emergency && ship._avoidStrafe) {
      const strafeDir = (ship.typeId % 2 === 0) ? 1 : -1;
      const perpAng = ship.ang + Math.PI * 0.5 * strafeDir;
      const strength = ship._avoidStrafeStrength || 1;
      const strafeForce = CFG.SHIP_THRUST * 0.25 * strength;
      ship.vx += Math.cos(perpAng) * strafeForce * dt;
      ship.vy += Math.sin(perpAng) * strafeForce * dt;
    }

    // Thrust
    ship.thrustOn = ship._aiThrust;
    if (ship._aiThrust) {
      const thrustMult = (ship.passive === 'nitro' ? 1.3 : 1.0) * (ship.passive === 'bioHull' ? 0.9 : 1.0);
      ship.vx += Math.cos(ship.ang) * CFG.SHIP_THRUST * thrustMult * dt;
      ship.vy += Math.sin(ship.ang) * CFG.SHIP_THRUST * thrustMult * dt;
      if (Math.random() < 0.6) spawnThrustParticle(ship);
      if (Math.random() < 0.6) spawnThrustParticle(ship);
    }
    } // end override skip

    // Friction
    const speed = Math.hypot(ship.vx, ship.vy);
    const maneuverSpeedMult = ship.maneuverActive ? (ship.maneuver === 'barrelRoll' ? 1.5 : ship.maneuver === 'quickTurn' ? 1.8 : ship.maneuver === 'serpentine' ? 2.5 : ship.maneuver === 'spinOut' ? 2.5 : ship._teleportPhase === 'phasing' ? 2 : 1) : 1;
    const reflectorSlow = (ship.maneuverActive && ship.maneuver === 'reflectorShields') ? 0.7 : 1;
    const maxSpeed = CFG.SHIP_MAX_SPEED * (ship.passive === 'nitro' ? 1.4 : 1) * (ship._hyperSpeedActive ? 3 : 1) * maneuverSpeedMult * reflectorSlow;
    if (speed > maxSpeed) {
      const ratio = maxSpeed / speed;
      ship.vx *= ratio;
      ship.vy *= ratio;
    }
    ship.vx *= (1 - 0.3 * dt);
    ship.vy *= (1 - 0.3 * dt);

    // Ice slow: reduce speed by up to 50%, decaying over 4s
    if (ship.iceSlow > 0) {
      const iceFactor = 1 - 0.5 * (ship.iceSlow / 2);
      ship.vx *= iceFactor;
      ship.vy *= iceFactor;
    }

    // Move
    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;

    // World bounds (soft bounce)
    {
    if (ship.x < 0) { ship.x = 0; ship.vx = Math.abs(ship.vx) * 0.5; }
    if (ship.x > CFG.WORLD_W) { ship.x = CFG.WORLD_W; ship.vx = -Math.abs(ship.vx) * 0.5; }
    if (ship.y < 0) { ship.y = 0; ship.vy = Math.abs(ship.vy) * 0.5; }
    if (ship.y > CFG.WORLD_H) { ship.y = CFG.WORLD_H; ship.vy = -Math.abs(ship.vy) * 0.5; }
    }

    // Process burst queue (triple-guns, gatling, flamethrower)
    processBurstQueue(ship);
    // Shoot
    if (ship._aiShoot && ship.fireCooldown <= 0 && ship._teleportPhase !== 'phasing'
        && !(ship.maneuverActive && ship.maneuver === 'reflectorShields')
        && !(ship.weapon.type === 'drone' && shipDrones.some(d => d.ownerId === ship.id))) {
      let fireRate = ship.weapon.fireRate;
      // Cryo-Coolant passive: 20% faster fire rate
      if (ship.passive === 'cryoCoolant') fireRate *= 0.8;
      // Barrel Roll maneuver: 30% faster fire rate
      if (ship.maneuverActive && ship.maneuver === 'barrelRoll') fireRate *= 0.7;
      // Turret Mode: 2x fire rate
      if (ship.maneuverActive && ship.maneuver === 'turretMode') fireRate *= 0.5;
      // Panic: 3x fire rate
      if (ship.maneuverActive && ship.maneuver === 'panic') fireRate *= 0.33;
      // Rapid Fire: 2x fire rate
      if (ship.maneuverActive && ship.maneuver === 'rapidFire') fireRate *= 0.5;
      // Jam rounds debuff: up to 10x slower fire rate, decaying over 4s
      if (ship.jamSlow > 0) {
        const jamMult = 1 + 9 * (ship.jamSlow / 4);
        fireRate *= jamMult;
      }
      ship.fireCooldown = fireRate;
      // Drone weapon: spawn array instead of firing
      if (ship.weapon.type === 'drone') {
        // Only spawn if no active drones for this ship
        const hasDrones = shipDrones.some(d => d.ownerId === ship.id);
        if (!hasDrones) {
          const w = ship.weapon;
          for (let di = 0; di < w.droneCount; di++) {
            shipDrones.push({
              ownerId: ship.id,
              ownerTeam: ship.team || 0,
              color: ship.color,
              x: ship.x, y: ship.y,
              vx: 0, vy: 0,
              ang: 0,
              orbitAngle: (Math.PI * 2 / w.droneCount) * di,
              orbitRadius: ship.r * 3,
              r: 5,
              spawnProgress: 0, // 0â†’1 over 0.3s, controls size and orbit radius
              damage: w.damage,
              life: w.life,
              armTimer: w.armTime,
              state: 'orbiting', // orbiting â†’ armed â†’ pursuing
              launchDelay: di * w.launchInterval, // stagger launches
              speed: w.speed,
              turnRate: w.turnRate,
              orbitSpeed: w.orbitSpeed,
            });
          }
          ship.fireCooldown = 0.5; // small delay, real cooldown set when all drones gone
        }
      } else {
        fireWeapon(ship);
      }

      // Fierce passive: thin ellipse shockwave from front when firing
      if (ship.passive === 'fierce') {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        shockwaves.push({ x: fx, y: fy, r: 0, maxR: 30, life: 0.2, maxLife: 0.2, color: ship.color, ellipse: true, ellipseAng: ship.ang });
      }

      // Cryo-Coolant passive: small particles from ship nose, perpendicular to fire direction
      if (ship.passive === 'cryoCoolant') {
        const fx = ship.x + Math.cos(ship.ang) * ship.r;
        const fy = ship.y + Math.sin(ship.ang) * ship.r;
        const perp = ship.ang + Math.PI / 2;
        for (let ci = 0; ci < 3; ci++) {
          const side = ci === 0 ? -1 : ci === 1 ? 1 : (Math.random() < 0.5 ? -1 : 1);
          particles.push({
            x: fx, y: fy,
            vx: Math.cos(perp) * side * rand(25, 55),
            vy: Math.sin(perp) * side * rand(25, 55),
            life: 0.2, maxLife: 0.2,
            color: ship.color, size: rand(1, 2),
          });
        }
      }
    }
  }

  // Update bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    // Store previous position for swept collision detection
    b._px = b.x; b._py = b.y;
    // â”€â”€ Special bullet behaviors â”€â”€
    // Homing missiles
    if (b.type === 'homing') {
      if (!b.armed) {
        b.armTime -= dt;
        if (b.armTime <= 0) {
          b.armed = true;
          b.vx = Math.cos(b.fireAng) * 300;
          b.vy = Math.sin(b.fireAng) * 300;
        }
      } else {
        let closest = null, cDist = Infinity;
        for (const s of ships) {
          if (!s.alive || s.id === b.owner) continue;
          if (b.ownerTeam > 0 && s.team === b.ownerTeam) continue;
          const d = dist(b, s);
          if (d < cDist) { cDist = d; closest = s; }
        }
        if (closest) {
          const tAng = angle(b, closest);
          const cAng = Math.atan2(b.vy, b.vx);
          const daTurn = shortAngleDist(cAng, tAng);
          const turnRate = 1.5;
          const turn = Math.sign(daTurn) * Math.min(Math.abs(daTurn), turnRate * dt);
          const nAng = cAng + turn;
          const spd = Math.hypot(b.vx, b.vy);
          b.vx = Math.cos(nAng) * spd;
          b.vy = Math.sin(nAng) * spd;
        }
      }
    }
    // Chaotic shot â€” random walk angular velocity
    if (b.curveRate) {
      const spd = Math.hypot(b.vx, b.vy);
      const cAng = Math.atan2(b.vy, b.vx);
      b.curveRate += rand(-10, 10) * dt;
      b.curveRate *= 0.97;
      const nAng = cAng + b.curveRate * dt;
      b.vx = Math.cos(nAng) * spd;
      b.vy = Math.sin(nAng) * spd;
    }
    // Snake shot â€” sine wave oscillation
    if (b.sineAmp) {
      const age = gameTime - b.spawnTime;
      // Growing amplitude for double helix
      const ampMult = b.helixGrow ? (1 + age * 1.5) : 1;
      const amp = b.sineAmp * ampMult * b.helixSide || b.sineAmp * ampMult;
      const angVel = amp * Math.cos(age * b.sineFreq);
      const spd = Math.hypot(b.vx, b.vy);
      const cAng = Math.atan2(b.vy, b.vx);
      const nAng = cAng + angVel * dt;
      b.vx = Math.cos(nAng) * spd;
      b.vy = Math.sin(nAng) * spd;
    }

    // Boomerang â€” arc back after 75% lifetime
    if (b.boomerang && b.maxLife) {
      const elapsed = b.maxLife - b.life;
      if (elapsed >= b.maxLife * 0.75) {
        if (!b.boomeranged) {
          b.boomeranged = true;
          const cAng = Math.atan2(b.vy, b.vx);
          b.boomerangTarget = cAng + Math.PI + rand(-Math.PI/2, Math.PI/2);
        }
        const spd = Math.hypot(b.vx, b.vy);
        const cAng = Math.atan2(b.vy, b.vx);
        const turnNeeded = shortAngleDist(cAng, b.boomerangTarget);
        const turnRate = 8; // radians/sec â€” fast arc
        const turn = Math.sign(turnNeeded) * Math.min(Math.abs(turnNeeded), turnRate * dt);
        const nAng = cAng + turn;
        const newSpd = Math.min(spd + 200 * dt, 450); // accelerate during arc
        b.vx = Math.cos(nAng) * newSpd;
        b.vy = Math.sin(nAng) * newSpd;
      }
    }

    // Cyclone â€” orbit around moving center
    if (b.cyclone) {
      const age = gameTime - b.spawnTime;
      // Center point moves forward
      b.cycloneCx += Math.cos(b.cycloneFireAng) * b.cycloneSpeed * dt * 0.85;
      b.cycloneCy += Math.sin(b.cycloneFireAng) * b.cycloneSpeed * dt * 0.85;
      // Orbit expands over time, varied per bullet
      b.cycloneAng += 6 * dt;
      const radius = (15 + age * 60) * (b.cycloneRadiusMult || 1);
      const targetX = b.cycloneCx + Math.cos(b.cycloneAng) * radius;
      const targetY = b.cycloneCy + Math.sin(b.cycloneAng) * radius;
      // Smoothly blend position toward orbit target
      const blend = Math.min(1, 12 * dt);
      const newX = lerp(b.x, targetX, blend);
      const newY = lerp(b.y, targetY, blend);
      // Set velocity from actual movement (for trails/collision)
      b.vx = (newX - b.x) / Math.max(dt, 0.001);
      b.vy = (newY - b.y) / Math.max(dt, 0.001);
      b.x = newX;
      b.y = newY;
    }

    // Lightning â€” zigzag and split
    if (b.lightning) {
      b.lightningZigTimer -= dt;
      if (b.lightningZigTimer <= 0) {
        b.lightningZigTimer = rand(0.03, 0.07);
        // Zigzag: deflect within Â±80Â° of original fire direction
        const spd = Math.hypot(b.vx, b.vy);
        const maxDev = 80 * Math.PI / 180; // 80Â° each side = 160Â° cone
        const newAng = b.lightningOrigAng + rand(-maxDev, maxDev);
        b.vx = Math.cos(newAng) * spd;
        b.vy = Math.sin(newAng) * spd;
      }
      // Split if splits remaining
      if (b.lightningSplitsLeft > 0) {
        const elapsed = (b.maxLife || 0.4) - b.life;
        const splitFrac = b.lightningSplitsLeft === 2 ? rand(0.25, 0.45) : rand(0.4, 0.7);
        const splitTime = (b.maxLife || 0.4) * splitFrac;
        if (elapsed >= splitTime) {
          b.lightningSplitsLeft--;
          const spd = Math.hypot(b.vx, b.vy);
          const maxDev = 80 * Math.PI / 180;
          const splitAng = b.lightningOrigAng + rand(-maxDev, maxDev);
          bullets.push({
            x: b.x, y: b.y,
            vx: Math.cos(splitAng) * spd,
            vy: Math.sin(splitAng) * spd,
            life: b.life,
            owner: b.owner, color: b.color,
            damage: b.damage, type: 'lightning',
            size: b.size,
            detonateTime: null, contactDetonate: false,
            isShrapnel: false, armed: true, armTime: 0,
            fireAng: b.fireAng, spawnTime: b.spawnTime,
            curveRate: 0, sineAmp: 0, sineFreq: 0,
            boomerang: false, maxLife: null,
            helixSide: 0, helixId: null, helixGrow: false,
            cyclone: false, cycloneAng: 0, cycloneCx: 0, cycloneCy: 0,
            cycloneFireAng: 0, cycloneSpeed: 0, cycloneId: null, cycloneRadiusMult: 1,
            lightning: true,
            lightningZigTimer: rand(0.03, 0.07),
            lightningOrigAng: b.lightningOrigAng,
            lightningSplitsLeft: b.lightningSplitsLeft, // child inherits remaining splits
            ownerPassive: b.ownerPassive,
          });
        }
      }
    }

    if (!b.cyclone) {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
    }
    b.life -= dt;

    // Detonation timer (grenade fuse, scrap split)
    if (b.detonateTime !== null && !b.isShrapnel) {
      b.detonateTime -= dt;
      if (b.detonateTime <= 0) {
        detonateBullet(b);
        bullets.splice(i, 1);
        continue;
      }
    }

    // Concussive shell split
    if (b.concussive) {
      b.concussiveTimer -= dt;
      if (b.concussiveTimer <= 0) {
        const w = WEAPON_DEFS.concussive;
        // Spawn 4 split projectiles in random directions
        for (let s = 0; s < w.splitCount; s++) {
          const splitAng = Math.random() * Math.PI * 2;
          const splitSpd = w.splitSpeed * rand(0.7, 1.3);
          bullets.push(makeBullet({id: b.owner, ang: splitAng, r: 6, x: b.x, y: b.y, vx: 0, vy: 0,
            weapon: {life: w.splitLife, damage: w.splitDmg, type: 'concussive'}},
            b.x, b.y,
            Math.cos(splitAng) * splitSpd + b.vx * 0.3,
            Math.sin(splitAng) * splitSpd + b.vy * 0.3,
            {life: w.splitLife, damage: w.splitDmg, concussive: false, size: 2, color: b.color}));
        }
        // Square particles at split site
        for (let p = 0; p < 10; p++) {
          particles.push({
            x: b.x + rand(-8, 8), y: b.y + rand(-8, 8),
            vx: rand(-60, 60), vy: rand(-60, 60),
            life: rand(0.2, 0.5), maxLife: 0.5,
            color: b.color, size: rand(2, 4), square: true,
          });
        }
        spawnExplosion(b.x, b.y, b.color, 6, 40);
        bullets.splice(i, 1);
        continue;
      }
    }

    // Bullet trail particle
    const _preTrailCount = particles.length;
    if (b.type === 'flamethrower') {
      // Flamethrower: dense flickering flame particles
      const age = gameTime - b.spawnTime;
      const nearShip = age < 0.2;
      const spawnCount = nearShip ? 1 : 3;
      const spawnChance = nearShip ? 0.3 : 1;
      if (Math.random() < spawnChance) {
        for (let tp = 0; tp < spawnCount; tp++) {
          const tLife = rand(0.15, 0.35);
          const fade = Math.max(0.3, 1 - age / (b.life + age));
          particles.push({
            x: b.x + rand(-4, 4),
            y: b.y + rand(-4, 4),
            vx: b.vx * rand(-0.05, 0.1) + rand(-20, 20),
            vy: b.vy * rand(-0.05, 0.1) + rand(-20, 20),
            life: tLife,
            maxLife: tLife,
            color: b.color,
            size: rand(1.5, 4) * fade,
          });
        }
      }
    } else if (b.sineAmp && b.type !== 'doublehelix') {
      // Snake bullets: dense, long-lasting glowing trail
      for (let tp = 0; tp < 2; tp++) {
        const tLife = rand(0.4, 0.8);
        particles.push({
          x: b.x + rand(-3, 3),
          y: b.y + rand(-3, 3),
          vx: -b.vx * 0.02 + rand(-6, 6),
          vy: -b.vy * 0.02 + rand(-6, 6),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(1.5, 3),
        });
      }
    } else if (b.type === 'alternating') {
      // Alternating lasers: small, lingering trail
      if (Math.random() < 0.7) {
        const tLife = rand(0.2, 0.4);
        particles.push({
          x: b.x + rand(-1, 1),
          y: b.y + rand(-1, 1),
          vx: -b.vx * 0.03 + rand(-3, 3),
          vy: -b.vy * 0.03 + rand(-3, 3),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(0.8, 1.5),
        });
      }
    } else if (b.type === 'sniper') {
      // Sniper: store trail positions for beam effect
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.35});
      // Age and prune trail
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'homing' && !b.isShrapnel) {
      // Homing missiles: smoky particle trail
      const tLife = rand(0.25, 0.5);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: -b.vx * 0.04 + rand(-10, 10),
        vy: -b.vy * 0.04 + rand(-10, 10),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2.5),
      });
      // Intermittent mini shockwaves
      if (Math.random() < 0.1) {
        shockwaves.push({
          x: b.x, y: b.y,
          r: 0, maxR: rand(10, 18),
          life: 0.4,
          color: b.color
        });
      }
    } else if (b.type === 'chaotic') {
      // Chaotic: store trail for perpendicular line effect
      if (!b.trail) b.trail = [];
      if (Math.random() < 0.4) {
        b.trail.push({x: b.x, y: b.y, life: 0.25, ang: Math.atan2(b.vy, b.vx)});
      }
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'doublehelix') {
      // Double helix: snake-like particle trail
      for (let tp = 0; tp < 2; tp++) {
        const tLife = rand(0.4, 0.8);
        particles.push({
          x: b.x + rand(-3, 3),
          y: b.y + rand(-3, 3),
          vx: -b.vx * 0.02 + rand(-6, 6),
          vy: -b.vy * 0.02 + rand(-6, 6),
          life: tLife,
          maxLife: tLife,
          color: b.color,
          size: rand(1.5, 3),
        });
      }
      // Cross-link lines between helix pair
      if (!b.trail) b.trail = [];
      const partner = bullets.find(o => o !== b && o.helixId === b.helixId);
      if (partner && Math.random() < 0.3) {
        const mx = (b.x + partner.x) / 2;
        const my = (b.y + partner.y) / 2;
        const linkAng = Math.atan2(partner.y - b.y, partner.x - b.x);
        const linkLen = Math.hypot(partner.x - b.x, partner.y - b.y) / 2;
        b.trail.push({x: mx, y: my, life: 0.3, ang: linkAng, len: linkLen});
      }
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'cyclone') {
      // Cyclone: long particle trails
      const tLife = rand(0.5, 1.0);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: rand(-8, 8),
        vy: rand(-8, 8),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2),
      });
    } else if (b.type === 'crossshot') {
      // Cross-shot: beam trail like sniper
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.25});
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'lightning') {
      // Lightning: beam trail that follows the zigzag path
      if (!b.trail) b.trail = [];
      b.trail.push({x: b.x, y: b.y, life: 0.4});
      for (let t = b.trail.length - 1; t >= 0; t--) {
        b.trail[t].life -= dt;
        if (b.trail[t].life <= 0) b.trail.splice(t, 1);
      }
    } else if (b.type === 'concussive' && b.concussive) {
      // Concussive: small square particles clustered around the shell
      if (Math.random() < 0.6) {
        const tLife = rand(0.15, 0.3);
        particles.push({
          x: b.x + rand(-4, 4), y: b.y + rand(-4, 4),
          vx: rand(-15, 15), vy: rand(-15, 15),
          life: tLife, maxLife: tLife,
          color: b.color, size: rand(1.5, 3), square: true,
        });
      }
    } else if (Math.random() < 0.5) {
      const tLife = rand(0.08, 0.15);
      particles.push({
        x: b.x + rand(-2, 2),
        y: b.y + rand(-2, 2),
        vx: -b.vx * 0.05 + rand(-8, 8),
        vy: -b.vy * 0.05 + rand(-8, 8),
        life: tLife,
        maxLife: tLife,
        color: b.color,
        size: rand(1, 2),
      });
    }
    // Tag trail particles from incendiary bullets
    if (b.incId && particles.length > _preTrailCount) {
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].incId = b.incId;
        particles[pi].incOwner = b.owner;
        particles[pi].incOwnerTeam = b.ownerTeam || 0;
      }
    }

    // Scope passive: bullet particle trails last twice as long
    if (b.ownerPassive === 'scope') {
      // Extend newly spawned trail particles
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].life *= 2;
        particles[pi].maxLife *= 2;
      }
      // Extend trail points (beam-style trails)
      if (b.trail) {
        for (const tp of b.trail) {
          if (tp._scoped) continue;
          tp.life *= 2;
          tp._scoped = true;
        }
      }
    }

    // Spark Drive passive: weapon particles double brightness (larger + brighter)
    if (b.ownerPassive === 'sparkDrive') {
      for (let pi = _preTrailCount; pi < particles.length; pi++) {
        particles[pi].size *= 1.5;
      }
    }

    // Debuff passive aura trails â€” particles perpendicular to bullet path
    const debuffColors = {
      iceRounds: '#55bbff', jamRounds: '#ff4444', stunShock: '#ffff44',
      override: '#8844dd', blindRounds: '#ff8800',
    };
    if (debuffColors[b.ownerPassive]) {
      const bSpd = Math.hypot(b.vx, b.vy);
      // Faster bullets spawn trails more reliably (lightning at 1600 u/s needs help)
      let spawnChance = Math.min(0.95, 0.5 + bSpd / 3000);
      if (b.ownerPassive === 'stunShock') spawnChance *= 0.5; // half density for stun
      if (bSpd > 10 && Math.random() < spawnChance) {
        const perpAng = Math.atan2(b.vy, b.vx) + Math.PI * 0.5;
        const side = Math.random() < 0.5 ? 1 : -1;
        if (b.ownerPassive === 'stunShock') {
          // Mini lightning arc: 3-4 jagged segments forking out perpendicular
          const arcLen = rand(15, 35);
          const segments = randInt(3, 4);
          const arcPoints = [{x: 0, y: 0}];
          for (let s = 1; s <= segments; s++) {
            const t = s / segments;
            // Main direction is perpendicular outward with jitter
            arcPoints.push({
              x: Math.cos(perpAng) * arcLen * t * side + rand(-6, 6),
              y: Math.sin(perpAng) * arcLen * t * side + rand(-6, 6)
            });
          }
          particles.push({
            x: b.x, y: b.y, vx: b.vx * 0.1, vy: b.vy * 0.1,
            life: rand(0.12, 0.22), maxLife: 0.22,
            color: '#ffff44', size: 1.5,
            isArc: true, arcPoints,
          });
        } else if (b.ownerPassive === 'iceRounds') {
          // Ice crystals: diamonds and snowflakes
          const spread = rand(6, 16);
          const px = b.x + Math.cos(perpAng) * spread * side;
          const py = b.y + Math.sin(perpAng) * spread * side;
          const driftSpd = rand(15, 45);
          const iceType = Math.random() < 0.6 ? 'diamond' : 'snowflake';
          particles.push({
            x: px, y: py,
            vx: Math.cos(perpAng) * driftSpd * side + b.vx * 0.05,
            vy: Math.sin(perpAng) * driftSpd * side + b.vy * 0.05,
            life: rand(0.2, 0.4), maxLife: 0.4,
            color: '#55bbff', size: rand(2, 4.5),
            isDiamond: iceType === 'diamond', isSnowflake: iceType === 'snowflake',
            spinAng: rand(0, Math.PI * 2),
          });
        } else {
          const spread = rand(4, (b.size || 2) + 10);
          const px = b.x + Math.cos(perpAng) * spread * side;
          const py = b.y + Math.sin(perpAng) * spread * side;
          const driftSpd = rand(8, 30);
          particles.push({
            x: px, y: py,
            vx: Math.cos(perpAng) * driftSpd * side + b.vx * 0.1,
            vy: Math.sin(perpAng) * driftSpd * side + b.vy * 0.1,
            life: rand(0.12, 0.25), maxLife: 0.25,
            color: debuffColors[b.ownerPassive],
            size: rand(1, 2.5),
          });
        }
      }
    }

    if (b.life <= 0 || b.x < -50 || b.x > CFG.WORLD_W + 50 || b.y < -50 || b.y > CFG.WORLD_H + 50) {
      if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
        orphanTrails.push({trail: b.trail, color: b.color});
      }
      bullets.splice(i, 1);
      continue;
    }

    // Absorber rounds: this bullet deletes enemy bullets it touches
    const absOwner = shipById[b.owner];
    if (absOwner && absOwner.passive === 'absorber') {
      for (let j = bullets.length - 1; j >= 0; j--) {
        if (j === i) continue;
        const ob = bullets[j];
        if (ob.owner === b.owner) continue;
        if (dist(b, ob) < 20) {
          spawnExplosion(ob.x, ob.y, '#fff', 4, 30);
          bullets.splice(j, 1);
          if (j < i) i--; // adjust index
        }
      }
    }

    // Bouncy Shot: ricochet both bullets on collision
    const bncOwner = shipById[b.owner];
    if (bncOwner && bncOwner.passive === 'bouncyShot' && (gameTime - (b._bounceTime || 0)) > 0.1) {
      for (let j = 0; j < bullets.length; j++) {
        if (j === i) continue;
        const ob = bullets[j];
        if (ob.owner === b.owner) continue;
        if ((gameTime - (ob._bounceTime || 0)) < 0.1) continue; // skip if just bounced
        if (dist(b, ob) < 12) {
          // Collision axis â€” handle degenerate overlap
          let cx = b.x - ob.x, cy = b.y - ob.y;
          let cd = Math.sqrt(cx * cx + cy * cy);
          if (cd < 0.5) {
            // Nearly overlapping â€” use bullet velocity as fallback
            const ba = Math.atan2(b.vy, b.vx);
            cx = Math.cos(ba); cy = Math.sin(ba); cd = 1;
          }
          const nx = cx / cd, ny = cy / cd;
          bounceBullet(b, nx, ny);
          bounceBullet(ob, -nx, -ny, true); // no double explosion
          break;
        }
      }
    }

    // Bullet vs asteroid
    let bulletHit = false;
    let _hitAst = null;
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const ast = asteroids[j];
      if (dist(b, ast) < ast.r) {
        _hitAst = {x: ast.x, y: ast.y, r: ast.r};
        const explodeScale = ast.r / 50;
        spawnExplosion(ast.x, ast.y, 'rgba(255,255,255,0.6)', Math.floor(8 * explodeScale), 100 * explodeScale);
        playAsteroidBreak();
        const ownerObl = shipById[b.owner];
        if (ownerObl && ownerObl.passive === 'obliterator') {
          // Obliterator: no fragments, emit 5 projectiles
          for (let k = 0; k < 5; k++) {
            const a = rand(0, Math.PI * 2);
            const sp = 400;
            bullets.push(makeBullet(ownerObl, ast.x, ast.y, Math.cos(a) * sp, Math.sin(a) * sp,
              { life: 0.8, damage: 2, type: 'basic', size: 2, isShrapnel: true, fireAng: a }));
          }
          spawnExplosion(ast.x, ast.y, ownerObl.color, 15, 120);
        } else if (ast.sizeIdx < 3) {
          const spread = ast.r * 0.4;
          for (let k = 0; k < 2; k++) {
            asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
          }
        } else if (CFG.RESPAWN_ASTEROIDS && asteroids.length < CFG.NUM_ASTEROIDS * 1.3) {
          const spawnChance = 0.25 + Math.min(0.35, gameTime / 90);
          if (Math.random() < spawnChance) {
            asteroids.push(spawnAsteroidOffscreen(1));
          }
        }
        asteroids.splice(j, 1);
        // Grenade contact detonation on asteroid
        if (b.contactDetonate && !b.isShrapnel) detonateBullet(b);
        bulletHit = true;
        break;
      }
    }

    if (bulletHit) {
      if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
        orphanTrails.push({trail: b.trail, color: b.color});
      }
      removeHelixPartner(b);
      // Piercing passive: bullet survives hitting an asteroid
      const ownerShip = shipById[b.owner];
      if (ownerShip && ownerShip.passive === 'bouncyShot') {
        // Bounce off asteroid surface
        const ha = _hitAst;
        const nx = (b.x - ha.x), ny = (b.y - ha.y);
        const nd = Math.sqrt(nx * nx + ny * ny) || 1;
        bounceBullet(b, nx / nd, ny / nd);
      } else if (!(ownerShip && ownerShip.passive === 'piercing')) {
        bullets.splice(i, 1);
        continue;
      }
    }

    // Bullet vs ship
    for (const ship of ships) {
      if (!ship.alive || ship.id === b.owner || ship.invuln > 0) continue;
      // Friendly fire disabled for first 10 seconds - bullets pass through teammates
      if (b.ownerTeam > 0 && ship.team === b.ownerTeam && gameTime < 10) continue;
      const bDist = dist(b, ship);

      // Swept collision for fast bullets (gatling etc): check line segment from prev to current pos
      const hitR = ship.r + 4;
      let didHit = bDist < hitR;
      if (!didHit && b._px !== undefined) {
        // Line segment (prevâ†’current) vs circle test
        const dx = b.x - b._px, dy = b.y - b._py;
        const fx = b._px - ship.x, fy = b._py - ship.y;
        const a2 = dx*dx + dy*dy;
        if (a2 > 0) {
          const b2 = 2*(fx*dx + fy*dy);
          const c2 = fx*fx + fy*fy - hitR*hitR;
          let disc = b2*b2 - 4*a2*c2;
          if (disc >= 0) {
            disc = Math.sqrt(disc);
            const t1 = (-b2 - disc) / (2*a2);
            const t2 = (-b2 + disc) / (2*a2);
            if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1)) {
              didHit = true;
            }
          }
        }
      }

      // Near-miss debuff detection: 2x hit radius applies effect only (no damage)
      const attacker = shipById[b.owner];
      if (attacker && bDist < hitR * 2 && bDist >= hitR) {
        if (attacker.passive === 'blindRounds') ship.blindTimer = 3;
        if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
        if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
        if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
        if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
        if (['blindRounds','iceRounds','jamRounds','stunShock','override'].includes(attacker.passive)) playDebuff();
      }

      if (didHit) {
        // Shield passive: absorb first hit
        if (ship.shieldActive) {
          ship.shieldActive = false;
          ship.hpBarTimer = 0.75;
          const shieldColor = b.color || '#fff';
          spawnExplosion(b.x, b.y, shieldColor, 8, 50);
          // Hex flash â€” 6 line particles radiating outward in hex pattern
          for (let h = 0; h < 6; h++) {
            const ha = (h / 6) * Math.PI * 2;
            const hSpd = rand(80, 150);
            particles.push({
              x: ship.x + Math.cos(ha) * ship.r * 0.5,
              y: ship.y + Math.sin(ha) * ship.r * 0.5,
              vx: Math.cos(ha) * hSpd, vy: Math.sin(ha) * hSpd,
              life: 0.3, maxLife: 0.3,
              color: ship.color, size: 1,
              isLine: true, lineAng: ha + Math.PI / 2, lineLen: rand(8, 14),
            });
          }
          shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: ship.color });
          // Still remove bullet (unless piercing)
        } else {
          // Shotgun damage decay: full damage for first 50% of life, then decays to 0.5 at max range
          let bulletDmg = b.damage || 1;
          if (b.type === 'shotgun') {
            const age = gameTime - b.spawnTime;
            const maxLife = age + b.life; // original total life
            const halfLife = maxLife * 0.5;
            if (age > halfLife) {
              const decayT = (age - halfLife) / (maxLife - halfLife); // 0â†’1 over second half
              bulletDmg = bulletDmg * (1 - decayT * 0.5); // full â†’ 50% of base
              bulletDmg = Math.max(0.5, bulletDmg); // floor at 0.5
            }
          }
          const dmg = bulletDmg * (ship.passive === 'titanium' ? 0.75 : 1);
          // Incendiary: 50% instant, 50% as burn DoT over 2s
          if (b.ownerPassive === 'incendiary') {
            ship.hp -= dmg * 0.5;
            ship.burnTimer = 2.0;
            ship.burnDps = (dmg * 0.5) / 2.0; // remaining 50% over 2s
          } else {
            ship.hp -= dmg;
          }
          ship.lastAttacker = b.owner;
          ship.lastAttackerTime = gameTime;
          ship.hpBarTimer = 0.75;
          const explodeSize = Math.min(12, 4 + dmg * 2);
          spawnExplosion(b.x, b.y, ship.color, explodeSize, 60 + dmg * 10);
          // Impact sparks â€” ricochet off at angles from bullet direction
          const bAng = Math.atan2(b.vy, b.vx);
          const impactAng = Math.atan2(b.y - ship.y, b.x - ship.x); // surface normal
          for (let sp = 0; sp < 4; sp++) {
            const sparkAng = impactAng + rand(-0.8, 0.8);
            const sparkSpd = rand(120, 280);
            particles.push({
              x: b.x, y: b.y,
              vx: Math.cos(sparkAng) * sparkSpd,
              vy: Math.sin(sparkAng) * sparkSpd,
              life: rand(0.1, 0.25), maxLife: 0.25,
              color: '#fff', size: rand(0.8, 1.5),
            });
          }
          playShipHit();
          // Hit Invincibility passive: 2s invuln after taking damage (16s cooldown)
          if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
            ship.invuln = 1;
            ship.hitInvulnCooldown = 8;
            ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
            ship.overrideTimer = 0; ship.blindTimer = 0;
            ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
          }
          // Ice/Jam rounds: apply debuff based on attacker's passive
          const attacker = shipById[b.owner];
          if (attacker) {
            if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
            if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
            if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
            if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
            if (attacker.passive === 'blindRounds') ship.blindTimer = 3;
            if (['blindRounds','iceRounds','jamRounds','stunShock','override','incendiary'].includes(attacker.passive)) playDebuff();
          }
          if (ship.hp <= 0) {
            killShip(ship, b.owner);
          }
        }
        // Grenade contact detonation on ship
        if (b.contactDetonate && !b.isShrapnel) detonateBullet(b);
        if (b.type === 'lightning' && b.trail && b.trail.length > 0) {
          orphanTrails.push({trail: b.trail, color: b.color});
        }
        removeHelixPartner(b);
        // Piercing passive: bullet survives hitting a ship
        const ownerShip = shipById[b.owner];
        if (ownerShip && ownerShip.passive === 'bouncyShot') {
          // Bounce off ship surface
          const nx = (b.x - ship.x), ny = (b.y - ship.y);
          const nd = Math.sqrt(nx * nx + ny * ny) || 1;
          bounceBullet(b, nx / nd, ny / nd);
        } else if (!(ownerShip && ownerShip.passive === 'piercing')) {
          bullets.splice(i, 1);
        }
        break;
      }
    }
  }

  // Age orphan trails (lightning beams that persist after bullet death)
  for (let i = orphanTrails.length - 1; i >= 0; i--) {
    const ot = orphanTrails[i];
    for (let t = ot.trail.length - 1; t >= 0; t--) {
      ot.trail[t].life -= dt;
      if (ot.trail[t].life <= 0) ot.trail.splice(t, 1);
    }
    if (ot.trail.length === 0) orphanTrails.splice(i, 1);
  }

  // Ship vs asteroid collision
  for (const ship of ships) {
    if (!ship.alive || ship.invuln > 0) continue;
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const ast = asteroids[j];
      if (dist(ship, ast) < ship.r + ast.r * 0.85) {
        // Drillbore passive: smash through asteroids but take chip damage
        if (ship.passive === 'drillbore') {
          const chipDmg = 0.4;
          ship.hp -= chipDmg;
          ship.hpBarTimer = 0.75;
          spawnExplosion(ast.x, ast.y, ship.color, 12, 80);
          playAsteroidBreak();
          if (ship.hp <= 0) killShip(ship, -1);
        // Shield passive: absorb asteroid hit
        } else if (ship.shieldActive) {
          ship.shieldActive = false;
          ship.hpBarTimer = 0.75;
          spawnExplosion(ship.x, ship.y, '#fff', 12, 80);
          shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: '#fff' });
        } else {
          const astDmg = ship.passive === 'flagship' ? 3 : 10;
          ship.hp -= astDmg * (ship.passive === 'titanium' ? 0.75 : 1);
          ship.hpBarTimer = 0.75;
          spawnExplosion(ship.x, ship.y, 'rgba(255,255,255,0.6)', 10, 80);
          playShipHit();
          if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
            ship.invuln = 1;
            ship.hitInvulnCooldown = 8;
            ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
            ship.overrideTimer = 0; ship.blindTimer = 0;
            ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
          }
          if (ship.hp <= 0) {
            killShip(ship, -1);
          }
        }
        // Destroy asteroid too
        if (ast.sizeIdx < 3) {
          const spread = ast.r * 0.4;
          for (let k = 0; k < 2; k++) {
            asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
          }
        }
        asteroids.splice(j, 1);
        break;
      }
    }
  }

  // Ship vs ship collision â€” both die
  for (let i = 0; i < ships.length; i++) {
    const a = ships[i];
    if (!a.alive || a._teleportPhase === 'phasing') continue;
    for (let j = i + 1; j < ships.length; j++) {
      const b = ships[j];
      if (!b.alive || b._teleportPhase === 'phasing') continue;
      // Skip teammate collisions for first 10 seconds
      if (a.team > 0 && a.team === b.team && gameTime < 10) continue;
      if (dist(a, b) < a.r + b.r) {
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;
        // White particles at midpoint, no shockwave
        for (let k = 0; k < 20; k++) {
          const pa = rand(0, Math.PI * 2);
          const sp = rand(20, 150);
          particles.push({ x:mx, y:my, vx:Math.cos(pa)*sp, vy:Math.sin(pa)*sp, life:rand(0.3,1.2), maxLife:1.2, color:'#fff', size:rand(1,3) });
        }
        spawnExplosion(a.x, a.y, a.color, 15, 100);
        spawnExplosion(b.x, b.y, b.color, 15, 100);
        playExplosion();
        // Kill both â€” attribute to each other (drillbore/shield survive)
        const aDrill = a.passive === 'drillbore';
        const bDrill = b.passive === 'drillbore';
        if (aDrill) { /* drillbore survives */ }
        else if (a.shieldActive) { a.shieldActive = false; spawnExplosion(a.x, a.y, b.color, 12, 80); shockwaves.push({ x: a.x, y: a.y, r: 0, maxR: 60, life: 0.4, color: b.color }); }
        else if (a.passive === 'flagship') { a.hp -= 3; a.hpBarTimer = 1; if (a.hp <= 0) killShip(a, b.id); }
        else { a.hp = 0; killShip(a, bDrill ? b.id : b.id); }
        if (bDrill) { /* drillbore survives */ }
        else if (b.shieldActive) { b.shieldActive = false; spawnExplosion(b.x, b.y, a.color, 12, 80); shockwaves.push({ x: b.x, y: b.y, r: 0, maxR: 60, life: 0.4, color: a.color }); }
        else if (b.passive === 'flagship') { b.hp -= 3; b.hpBarTimer = 1; if (b.hp <= 0) killShip(b, a.id); }
        else { b.hp = 0; killShip(b, aDrill ? a.id : a.id); }
      }
    }
  }

  // Update asteroids
  for (const ast of asteroids) {
    ast.x += ast.vx * dt;
    ast.y += ast.vy * dt;
    ast.rot += ast.rotSpeed * dt;
    // Wrap (skip border decoration asteroids)
    if (!ast.isBorder) {
      ast.x = wrap(ast.x, CFG.WORLD_W);
      ast.y = wrap(ast.y, CFG.WORLD_H);
    }
  }

  } // end !skipGameplay

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= (1 - 3 * dt);
    p.vy *= (1 - 3 * dt);
    p.life -= dt;
    // Incendiary trail damage check
    if (p.incId && !incSpentBullets.has(p.incId)) {
      for (const ship of ships) {
        if (!ship.alive || ship.id === p.incOwner || ship.invuln > 0) continue;
        if (p.incOwnerTeam > 0 && ship.team === p.incOwnerTeam) continue;
        if (Math.hypot(p.x - ship.x, p.y - ship.y) < ship.r + 3) {
          const dmg = 0.5 * (ship.passive === 'titanium' ? 0.75 : 1);
          if (ship.shieldActive) {
            ship.shieldActive = false;
            const shieldColor = p.color || '#f80';
            spawnExplosion(p.x, p.y, shieldColor, 6, 40);
            shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: 60, life: 0.4, color: shieldColor });
          } else {
            ship.hp -= dmg;
            ship.lastAttacker = p.incOwner;
            ship.lastAttackerTime = gameTime;
            ship.hpBarTimer = 0.75;
            spawnExplosion(p.x, p.y, '#f80', 4, 30);
            const attacker = shipById[p.incOwner];
            if (attacker) {
              if (attacker.passive === 'iceRounds') { ship.iceSlow = 2; ship.iceDotTimer = 2.0; }
              if (attacker.passive === 'jamRounds') ship.jamSlow = 4;
              if (attacker.passive === 'stunShock') ship.stunTimer = 1.75;
              if (attacker.passive === 'override') { ship.overrideTimer = 2; ship.overrideTurnDir = Math.random() < 0.5 ? -1 : 1; }
            }
            if (ship.passive === 'hitInvuln' && ship.hp > 0 && ship.hitInvulnCooldown <= 0) {
              ship.invuln = 1; ship.hitInvulnCooldown = 8;
              ship.iceSlow = 0; ship.jamSlow = 0; ship.stunTimer = 0;
              ship.overrideTimer = 0; ship.blindTimer = 0;
              ship.burnTimer = 0; ship.burnDps = 0; ship.iceDotTimer = 0;
            }
            if (ship.hp <= 0) killShip(ship, p.incOwner);
          }
          incSpentBullets.add(p.incId);
          break;
        }
      }
    }
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    // Cull offscreen particles (20% buffer beyond viewport)
    const _hvw = (W / camZoom) * 0.6, _hvh = (H / camZoom) * 0.6;
    if (p.x < cameraX - _hvw || p.x > cameraX + _hvw || p.y < cameraY - _hvh || p.y > cameraY + _hvh) particles.splice(i, 1);
  }

  // Update shockwaves
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const s = shockwaves[i];
    s.life -= dt;
    const sMaxLife = s.maxLife || 0.4;
    s.r = Math.max(0, s.maxR * (1 - s.life / sMaxLife));
    if (s.life <= 0) shockwaves.splice(i, 1);
  }

  // Update death glows
  for (let i = deathGlows.length - 1; i >= 0; i--) {
    deathGlows[i].life -= dt;
    if (deathGlows[i].life <= 0) deathGlows.splice(i, 1);
  }

  // Update smoke decoys
  for (let i = smokeDecoys.length - 1; i >= 0; i--) {
    smokeDecoys[i].life -= dt;
    if (smokeDecoys[i].life <= 0) smokeDecoys.splice(i, 1);
  }

  // Update ship clones (Double Team)
  for (let i = shipClones.length - 1; i >= 0; i--) {
    const clone = shipClones[i];
    if (!clone.alive) { shipClones.splice(i, 1); continue; }

    // If hit, count down flash timer (2x faster than before)
    if (clone.hit) {
      clone.hitTimer -= dt;
      if (clone.hitTimer <= 0) {
        spawnExplosion(clone.x, clone.y, clone.color, 10, 60);
        clone.alive = false;
        shipClones.splice(i, 1);
        continue;
      }
    }

    clone.life -= dt;
    if (clone.life <= 0) {
      spawnExplosion(clone.x, clone.y, clone.color, 8, 40);
      shipClones.splice(i, 1);
      continue;
    }

    const parent = shipById[clone.ownerId];
    if (!parent || !parent.alive) {
      spawnExplosion(clone.x, clone.y, clone.color, 8, 40);
      shipClones.splice(i, 1);
      continue;
    }

    // Orbit around parent â€” radius doubles over duration
    clone.orbitElapsed += dt;
    const expansionT = Math.min(1, clone.orbitElapsed / (clone.orbitDuration || 4));
    const curRadius = clone.orbitRadiusBase * (1 + expansionT); // 1x â†’ 2x
    clone.orbitAngle += 1.2 * dt; // slow orbit speed
    clone.x = parent.x + Math.cos(clone.orbitAngle) * curRadius;
    clone.y = parent.y + Math.sin(clone.orbitAngle) * curRadius;
    clone.ang = parent.ang; // face same direction as parent

    // Block bullet collisions (bullets destroy clone)
    if (!clone.hit) {
      for (const b of bullets) {
        if (b.owner === clone.ownerId) continue;
        if (dist(b, clone) < clone.r + 4) {
          clone.hit = true;
          clone.hitTimer = 0.25; // 2x faster fade
          b.life = 0;
          break;
        }
      }
    }

    // Asteroid collisions destroy clone
    if (!clone.hit) {
      for (const ast of asteroids) {
        if (dist(clone, ast) < clone.r + ast.r * 0.85) {
          clone.hit = true;
          clone.hitTimer = 0.25;
          break;
        }
      }
    }
  }

  // Update debris field (Dump Debris) â€” absorb incoming projectiles
  for (let i = debrisField.length - 1; i >= 0; i--) {
    const d = debrisField[i];
    d.life -= dt;
    if (d.life <= 0) { debrisField.splice(i, 1); continue; }
    // Move with drag
    d.x += d.vx * dt;
    d.y += d.vy * dt;
    d.vx *= 1 - 1.5 * dt;
    d.vy *= 1 - 1.5 * dt;
    // Absorb bullets (not from the owner)
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (b.owner === d.ownerId) continue;
      const dx = b.x - d.x, dy = b.y - d.y;
      if (dx * dx + dy * dy < (d.size + 4) * (d.size + 4)) {
        // Absorb: destroy both debris piece and bullet
        b.life = 0;
        debrisField.splice(i, 1);
        break;
      }
    }
  }

  // Update reflector shields â€” orbit and reflect bullets
  for (let i = reflectorShields.length - 1; i >= 0; i--) {
    const rs = reflectorShields[i];
    rs.life -= dt;
    if (rs.life <= 0) { reflectorShields.splice(i, 1); continue; }
    const parent = shipById[rs.ownerId];
    if (!parent || !parent.alive) { reflectorShields.splice(i, 1); continue; }

    // Calculate current position on orbit
    const ang = parent._reflectorAngle + rs.baseAngle;
    rs.cx = parent.x + Math.cos(ang) * rs.orbitRadius;
    rs.cy = parent.y + Math.sin(ang) * rs.orbitRadius;
    rs.ang = ang + Math.PI * 0.5; // shield faces tangent to orbit

    // Check bullet collisions â€” line segment vs point
    const cosA = Math.cos(rs.ang), sinA = Math.sin(rs.ang);
    const x1 = rs.cx - cosA * rs.halfLength, y1 = rs.cy - sinA * rs.halfLength;
    const x2 = rs.cx + cosA * rs.halfLength, y2 = rs.cy + sinA * rs.halfLength;

    for (const b of bullets) {
      if (b.owner === rs.ownerId) continue; // own bullets pass through
      // Distance from bullet to line segment
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx * dx + dy * dy;
      const t = Math.max(0, Math.min(1, ((b.x - x1) * dx + (b.y - y1) * dy) / len2));
      const px = x1 + t * dx, py = y1 + t * dy;
      const d2 = (b.x - px) * (b.x - px) + (b.y - py) * (b.y - py);
      if (d2 < 8 * 8) { // 8px hit radius
        // Reflect: reverse velocity
        b.vx = -b.vx;
        b.vy = -b.vy;
        // Push bullet away from shield to prevent re-collision
        b.x += b.vx * 0.05;
        b.y += b.vy * 0.05;
        // Change ownership so it can damage the original shooter
        b.owner = rs.ownerId;
        b.color = parent.color;
        // Spark effect
        spawnExplosion(px, py, parent.color, 4, 20);
      }
    }
  }

  // Update repulsor pushes â€” tick down timer and push bullets
  for (const ship of ships) {
    if (ship._repulsorLife > 0) {
      const prevR = ship._repulsorRadius * (1 - ship._repulsorLife / ship._repulsorMaxLife);
      ship._repulsorLife -= dt;
      const curR = ship._repulsorRadius * (1 - Math.max(0, ship._repulsorLife) / ship._repulsorMaxLife);
      const bandInner = prevR;
      const bandOuter = curR + 30; // slight thickness to catch fast bullets
      // Erase enemy projectiles the wavefront passes over
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        if (b.owner === ship.id) continue;
        const dx = b.x - ship._repulsorX, dy = b.y - ship._repulsorY;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d >= bandInner && d < bandOuter) {
          spawnExplosion(b.x, b.y, '#fff', 3, 20);
          bullets.splice(bi, 1);
        }
      }
      // Push particles the wavefront passes over
      for (const p of particles) {
        const dx = p.x - ship._repulsorX, dy = p.y - ship._repulsorY;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d >= bandInner && d < bandOuter && d > 1) {
          const nx = dx / d, ny = dy / d;
          p.vx += nx * 600;
          p.vy += ny * 600;
        }
      }
      if (ship._repulsorLife <= 0) ship._repulsorLife = 0;
    }
  }

  // Update mines (Mine Field) â€” proximity, bullet, and asteroid detonation
  for (let i = mines.length - 1; i >= 0; i--) {
    const mine = mines[i];
    mine.life -= dt;
    if (mine.life <= 0) { mines.splice(i, 1); continue; }

    // Arm timer â€” mine cannot detonate until placed for 1s
    if (mine.armTimer > 0) { mine.armTimer -= dt; continue; }

    let detonate = false;

    // Proximity: enemy ship within 200 units
    for (const ship of ships) {
      if (ship.id === mine.ownerId || !ship.alive) continue;
      if (dist(mine, ship) < mine.proximityRadius) { detonate = true; break; }
    }

    // Bullet strike: any projectile from any owner
    if (!detonate) {
      for (const b of bullets) {
        if (b.isShrapnel) continue;
        if (dist(mine, b) < mine.r + 4) {
          b.life = 0; // consume the bullet
          detonate = true;
          break;
        }
      }
    }

    // Asteroid strike
    if (!detonate) {
      for (const ast of asteroids) {
        if (dist(mine, ast) < mine.r + ast.r * 0.85) { detonate = true; break; }
      }
    }

    if (detonate) {
      detonateMine(mine);
      mines.splice(i, 1);
    }
  }

  // Update ship drones (Drone Array weapon)
  for (let i = shipDrones.length - 1; i >= 0; i--) {
    const d = shipDrones[i];
    d.life -= dt;
    if (d.life <= 0) {
      shipDrones.splice(i, 1);
      continue;
    }

    const parent = shipById[d.ownerId];

    if (d.state === 'orbiting' || d.state === 'armed') {
      // If parent dead, release all orbiting drones as pursuing
      if (!parent || !parent.alive) {
        d.state = 'pursuing';
        d._drawScale = 1;
        d.life = 2.0; // reset lifetime
        const a = d.orbitAngle;
        d.vx = Math.cos(a) * d.speed;
        d.vy = Math.sin(a) * d.speed;
        continue;
      }

      // Orbit around parent
      // Spawn animation: expand from half-radius to full over 0.3s
      if (d.spawnProgress < 1) {
        d.spawnProgress = Math.min(1, d.spawnProgress + dt / 0.3);
      }
      const t = d.spawnProgress * d.spawnProgress; // ease-in curve
      const curRadius = d.orbitRadius * (0.3 + 0.7 * t);
      const angularSpeed = d.orbitSpeed / curRadius;
      d.orbitAngle += angularSpeed * dt;
      d.x = parent.x + Math.cos(d.orbitAngle) * curRadius;
      d.y = parent.y + Math.sin(d.orbitAngle) * curRadius;
      d.ang = d.orbitAngle + Math.PI * 0.5; // face tangent
      d._drawScale = 0.1 + 0.9 * t; // visual size scale for rendering

      // Count down arm timer
      if (d.state === 'orbiting') {
        d.armTimer -= dt;
        if (d.armTimer <= 0) d.state = 'armed';
      }

      // Armed: count down individual launch delay, then find target
      if (d.state === 'armed') {
        d.launchDelay -= dt;
        if (d.launchDelay <= 0) {
          // Find closest enemy in range
          let closest = null, cDist = Infinity;
          for (const s of ships) {
            if (!s.alive || s.id === d.ownerId) continue;
            if (d.ownerTeam > 0 && s.team === d.ownerTeam) continue;
            const dd = dist(d, s);
            if (dd < cDist) { cDist = dd; closest = s; }
          }
          if (closest) {
            // Launch toward target
            d.state = 'pursuing';
            d._drawScale = 1;
            d.life = 2.0; // reset lifetime so drones don't all expire at once
            const tAng = angle(d, closest);
            d.vx = Math.cos(tAng) * d.speed;
            d.vy = Math.sin(tAng) * d.speed;
            // Breakaway ellipse particle
            shockwaves.push({ x: d.x, y: d.y, r: 0, maxR: 15, life: 0.2, maxLife: 0.2, color: d.color, ellipse: true, ellipseAng: tAng });
          }
        }
      }

      // Collision damage while orbiting (contact damage)
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId) continue;
        if (dist(d, s) < d.r + s.r) {
          // Deal damage
          s.hp -= d.damage;
          s.hpBarTimer = 1;
          s.lastAttacker = d.ownerId;
          s.lastAttackerTime = gameTime;
          spawnExplosion(d.x, d.y, d.color, 6, 30);
          shipDrones.splice(i, 1);
          if (s.hp <= 0 && s.alive) {
            killShip(s, d.ownerId);
          }
          break;
        }
      }
      if (!shipDrones[i] || shipDrones[i] !== d) continue;

      // Orbiting/armed drones neutralize enemy bullets on contact
      let droneZapped = false;
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (b.owner === d.ownerId) continue;
        if (dist(d, b) < d.r + 4) {
          spawnExplosion(b.x, b.y, '#fff', 4, 20);
          bullets.splice(j, 1);
          shipDrones.splice(i, 1);
          droneZapped = true;
          break;
        }
      }
      if (droneZapped) continue;
    }

    if (d.state === 'pursuing') {
      // Moderate homing â€” tracks nearby enemies
      let closest = null, cDist = Infinity;
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId) continue;
        const dd = dist(d, s);
        if (dd < cDist) { cDist = dd; closest = s; }
      }
      if (closest) {
        const tAng = angle(d, closest);
        const cAng = Math.atan2(d.vy, d.vx);
        const da = shortAngleDist(cAng, tAng);
        const turn = Math.sign(da) * Math.min(Math.abs(da), d.turnRate * dt);
        const nAng = cAng + turn;
        const spd = Math.hypot(d.vx, d.vy);
        d.vx = Math.cos(nAng) * spd;
        d.vy = Math.sin(nAng) * spd;
      }

      // Move
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      d.ang = Math.atan2(d.vy, d.vx);

      // Box particle trail
      if (Math.random() < 0.5) {
        particles.push({
          x: d.x + rand(-3, 3), y: d.y + rand(-3, 3),
          vx: -d.vx * 0.2 + rand(-15, 15), vy: -d.vy * 0.2 + rand(-15, 15),
          life: rand(0.2, 0.4), maxLife: 0.4, color: d.color, size: rand(1.5, 3),
          isSquare: true,
        });
      }

      // Hit ships
      let hit = false;
      for (const s of ships) {
        if (!s.alive || s.id === d.ownerId || s.invuln > 0) continue;
        if (d.ownerTeam > 0 && s.team === d.ownerTeam) continue;
        if (dist(d, s) < d.r + s.r) {
          // Shield passive: absorb first hit
          if (s.shieldActive) {
            s.shieldActive = false;
            spawnExplosion(d.x, d.y, '#fff', 8, 50);
          } else {
            s.hp -= d.damage;
            if (s.hp <= 0 && s.alive) {
              killShip(s, d.ownerId);
            }
          }
          s.hpBarTimer = 1;
          s.lastAttacker = d.ownerId;
          s.lastAttackerTime = gameTime;
          spawnExplosion(d.x, d.y, d.color, 8, 40);
          hit = true;
          break;
        }
      }

      // Hit asteroids â€” drone and asteroid both destroyed
      if (!hit) {
        for (let ai = asteroids.length - 1; ai >= 0; ai--) {
          const ast = asteroids[ai];
          if (dist(d, ast) < d.r + ast.r * 0.85) {
            // Break the asteroid like a bullet would
            const explodeScale = ast.r / 50;
            spawnExplosion(ast.x, ast.y, 'rgba(255,255,255,0.6)', Math.floor(8 * explodeScale), 100 * explodeScale);
            playAsteroidBreak();
            if (ast.sizeIdx < 3) {
              const spread = ast.r * 0.4;
              for (let k = 0; k < 2; k++) {
                asteroids.push(spawnAsteroid(ast.sizeIdx + 1, ast.x + rand(-spread, spread), ast.y + rand(-spread, spread)));
              }
            } else if (CFG.RESPAWN_ASTEROIDS && asteroids.length < CFG.NUM_ASTEROIDS * 1.3) {
              const spawnChance = 0.25 + Math.min(0.35, gameTime / 90);
              if (Math.random() < spawnChance) {
                asteroids.push(spawnAsteroidOffscreen(1));
              }
            }
            asteroids.splice(ai, 1);
            spawnExplosion(d.x, d.y, d.color, 5, 25);
            hit = true;
            break;
          }
        }
      }

      // Pursuing drones also neutralize enemy bullets on contact
      if (!hit) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (b.owner === d.ownerId) continue;
          if (dist(d, b) < d.r + 4) {
            spawnExplosion(b.x, b.y, '#fff', 4, 20);
            bullets.splice(j, 1);
            hit = true;
            break;
          }
        }
      }

      if (hit) {
        shipDrones.splice(i, 1);
        continue;
      }

      // Bounds â€” soft bounce
      if (d.x < 0 || d.x > CFG.WORLD_W) d.vx = -d.vx;
      if (d.y < 0 || d.y > CFG.WORLD_H) d.vy = -d.vy;
    }
  }

  // Set 4s cooldown when all drones are gone for a drone-weapon ship
  for (const ship of ships) {
    if (!ship.alive || ship.weapon.type !== 'drone') continue;
    const hasDrones = shipDrones.some(d => d.ownerId === ship.id);
    if (!hasDrones && ship.fireCooldown < 4.0 && ship._droneWasActive) {
      ship.fireCooldown = 4.0;
      ship._droneWasActive = false;
    }
    if (hasDrones) ship._droneWasActive = true;
  }

  // Finale slow-mo: triggered by the killing blow in killShip
  if (finaleMode) {
    finaleTimer += rawDt;
    // Dramatic slowdown curve: stays near-frozen throughout
    finaleSlowMo = 0.03 + Math.min(0.05, finaleTimer * 0.02);
    finaleFlash = Math.max(0, finaleFlash - rawDt * 2.5);

    // Screen shake â€” intense at first, decays over ~1.5s
    const shakeIntensity = Math.max(0, 1 - finaleTimer / 1.5);
    const shakeAmount = shakeIntensity * 12;
    screenShakeX = (Math.random() - 0.5) * 2 * shakeAmount;
    screenShakeY = (Math.random() - 0.5) * 2 * shakeAmount;

    // Camera stays where it is â€” no target override

    if (finaleTimer > 3.5 && !gameOver) {
      gameOver = true;
      winner = ships.find(s => s.alive) || null; // null = draw
      setTimeout(showWinner, 500);
    }
  } else {
    screenShakeX = 0;
    screenShakeY = 0;
  }

  // Normal win check (fallback if somehow missed)
  const aliveCount = ships.filter(s => s.alive).length;
  if (aliveCount <= 1 && !gameOver && !finaleMode) {
    gameOver = true;
    winner = ships.find(s => s.alive) || null;
    setTimeout(showWinner, 1000);
  }

  updateScoreboard();

  // â”€â”€ CAMERA â”€â”€
  if (!finaleMode) updateCamera(dt, rawDt);

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    const _hvw2 = (W / camZoom) * 0.6, _hvh2 = (H / camZoom) * 0.6;
    if (p.x < cameraX - _hvw2 || p.x > cameraX + _hvw2 || p.y < cameraY - _hvh2 || p.y > cameraY + _hvh2) particles.splice(i, 1);
  }
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const sw = shockwaves[i];
    sw.life -= dt;
    sw.r += (sw.maxR / 0.4) * dt;
    if (sw.life <= 0) shockwaves.splice(i, 1);
  }
  // Death glows
  for (let i = deathGlows.length - 1; i >= 0; i--) {
    deathGlows[i].life -= dt;
    if (deathGlows[i].life <= 0) deathGlows.splice(i, 1);
  }
  // Smoke decoys
  for (let i = smokeDecoys.length - 1; i >= 0; i--) {
    smokeDecoys[i].life -= dt;
    if (smokeDecoys[i].life <= 0) smokeDecoys.splice(i, 1);
  }
  // Debris field
  for (let i = debrisField.length - 1; i >= 0; i--) {
    const d = debrisField[i];
    d.x += d.vx * dt; d.y += d.vy * dt;
    d.vx *= (1 - 0.5 * dt); d.vy *= (1 - 0.5 * dt);
    d.life -= dt;
    if (d.life <= 0) debrisField.splice(i, 1);
  }
  // Reflector shields
  for (let i = reflectorShields.length - 1; i >= 0; i--) {
    reflectorShields[i].life -= dt;
    if (reflectorShields[i].life <= 0) reflectorShields.splice(i, 1);
  }
  // Mines
  for (let i = mines.length - 1; i >= 0; i--) {
    const m = mines[i];
    m.life -= dt; m.armTimer -= dt;
    if (m.armTimer <= 0) {
      for (const s of ships) {
        if (!s.alive || s.id === m.ownerId) continue;
        if (dist(m, s) < m.proximityRadius) {
          detonateMine(m);
          mines.splice(i, 1);
          break;
        }
      }
    }
    if (m.life <= 0) mines.splice(i, 1);
  }

  // Update HUD
  updateHUD();
}

// â”€â”€â”€ KILL SHIP (Versus mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function killShip(ship, killerId) {
  ship.alive = false;
  ship.deathTime = gameTime;
  ship.placement = ships.filter(s => s.alive).length + 1;
  const deathLifeMult = ship.passive === 'flagship' ? 3 : 1;
  const deathCount = ship.passive === 'flagship' ? 80 : 40;
  for (let i = 0; i < deathCount; i++) {
    const a = rand(0, Math.PI * 2);
    const sp = rand(20, 200);
    particles.push({
      x: ship.x, y: ship.y,
      vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: rand(0.6, 2.4) * deathLifeMult, maxLife: 2.4 * deathLifeMult,
      color: ship.color, size: rand(1, 3),
    });
  }
  shockwaves.push({ x: ship.x, y: ship.y, r: 0, maxR: ship.passive === 'flagship' ? 300 : 160, life: 0.4, color: ship.color });
  playExplosion();
  deathGlows.push({ x: ship.x, y: ship.y, color: ship.color, life: 7.5, maxLife: 7.5 });

  if (killerId < 0 && ship.lastAttacker >= 0 && (gameTime - ship.lastAttackerTime) < 2.5) {
    killerId = ship.lastAttacker;
  }
  const killer = killerId >= 0 ? shipById[killerId] : null;
  if (killer && killer.alive) {
    killer.kills++;
    if (killer.passive === 'scrapRepair') {
      killer.hp += 1.5;
      killer.hpBarTimer = 0.75;
      // Plus sign particle effect
      for (let p = 0; p < 8; p++) {
        const isHoriz = p < 4;
        const t = (p % 4) / 3 - 0.5;
        const px = isHoriz ? t * 20 : 0;
        const py = isHoriz ? 0 : t * 20;
        particles.push({
          x: killer.x + px, y: killer.y + py - 15,
          vx: rand(-10, 10), vy: rand(-30, -15),
          life: 0.8, maxLife: 0.8,
          color: '#0f0', size: 2.5,
        });
      }
    }
    if (killer.passive === 'detonator') {
      for (let di = 0; di < 25; di++) {
        const a = (di / 25) * Math.PI * 2;
        bullets.push(makeBullet(killer, ship.x, ship.y, Math.cos(a) * 500, Math.sin(a) * 500,
          { life: 1, damage: 2, type: 'basic', size: 2.5, isShrapnel: true, fireAng: a }));
      }
      spawnExplosion(ship.x, ship.y, killer.color, 30, 250);
    }
  }
  if (killerId < 0) asteroidKills++;

  const killerName = killer ? killer.name : 'ASTEROID';
  const killerColor = killer ? killer.color : '#888';
  ship.killedBy = killerName;
  addKillMessage(killerName, killerColor, ship.name, ship.color);

  // Check win condition
  const isFFA = matchMode === 'ffa';
  let shouldFinale = false;

  if (isFFA) {
    const aliveCount = ships.filter(s => s.alive).length;
    if (aliveCount <= 1 && !finaleMode) shouldFinale = true;
  } else {
    const teamsAlive = new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team));
    if (teamsAlive.size <= 1 && !finaleMode) shouldFinale = true;
  }

  if (shouldFinale) {
    finaleMode = true;
    finaleTimer = 0;
    finaleFlash = 1;
    // Grant invuln to survivors
    for (const s of ships) {
      if (s.alive) s.invuln = Infinity;
    }
    finaleDeath = {
      x: ship.x, y: ship.y,
      color: ship.color,
      killerColor: killerColor,
      killerName: killerName,
    };
    playFinaleExplosion();
    spawnExplosion(ship.x, ship.y, killerColor, 60, 300);
    spawnExplosion(ship.x, ship.y, ship.color, 40, 250);
  }
}

// â”€â”€â”€ DOGFIGHT DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function findBestDogfight() {
  const alive = ships.filter(s => s.alive && s._teleportPhase !== 'phasing');
  if (alive.length < 2) return null;
  let bestPair = null, bestScore = -Infinity;
  for (let i = 0; i < alive.length; i++) {
    for (let j = i + 1; j < alive.length; j++) {
      const a = alive[i], b = alive[j];
      // Prefer cross-team pairs
      if (a.team === b.team) continue;
      const d = dist(a, b);
      const proxScore = Math.max(0, 2000 - d) / 2000;
      let aShotsAtB = 0, bShotsAtA = 0;
      for (const bul of bullets) {
        if (bul.owner === a.id) {
          const toBx = b.x - bul.x, toBy = b.y - bul.y;
          const dot = toBx * bul.vx + toBy * bul.vy;
          if (dot > 0 && Math.hypot(toBx, toBy) < 800) aShotsAtB++;
        } else if (bul.owner === b.id) {
          const toAx = a.x - bul.x, toAy = a.y - bul.y;
          const dot = toAx * bul.vx + toAy * bul.vy;
          if (dot > 0 && Math.hypot(toAx, toAy) < 800) bShotsAtA++;
        }
      }
      const fireScore = Math.min(aShotsAtB, bShotsAtA) * 3 + aShotsAtB + bShotsAtA;
      let stabilityBonus = 0;
      if (dogfightPair && ((dogfightPair[0] === a.id && dogfightPair[1] === b.id) ||
          (dogfightPair[0] === b.id && dogfightPair[1] === a.id))) stabilityBonus = 2;
      const score = proxScore * 5 + fireScore + stabilityBonus;
      if (score > bestScore) { bestScore = score; bestPair = [a, b]; }
    }
  }
  return bestPair;
}

// â”€â”€â”€ CAMERA (Versus) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _camTargetSmX = 0, _camTargetSmY = 0, _camTargetSmZ = 0.5;

function updateCamera(dt, rawDt) {
  const alive = ships.filter(s => s.alive);
  if (alive.length === 0) return;

  // Bounding box of alive ships only (no bullets â€” they cause jitter)
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const s of alive) {
    // Include a velocity-lookahead so camera leads slightly
    const lx = s.x + s.vx * 0.3;
    const ly = s.y + s.vy * 0.3;
    minX = Math.min(minX, lx); maxX = Math.max(maxX, lx);
    minY = Math.min(minY, ly); maxY = Math.max(maxY, ly);
  }

  // Padding scales with ship count â€” tighter framing
  const pad = 200 + alive.length * 15;
  const rawTargetX = (minX + maxX) / 2;
  const rawTargetY = (minY + maxY) / 2;

  // Zoom to fit
  const spreadX = maxX - minX + pad;
  const spreadY = maxY - minY + pad;
  const zoomX = W / spreadX;
  const zoomY = H / spreadY;
  const rawTargetZ = Math.max(0.15, Math.min(1.5, Math.min(zoomX, zoomY)));

  // Smooth the target itself to prevent sudden jumps (double-smooth)
  const targetSmooth = 1 - Math.pow(0.05, rawDt);
  _camTargetSmX = lerp(_camTargetSmX || rawTargetX, rawTargetX, targetSmooth);
  _camTargetSmY = lerp(_camTargetSmY || rawTargetY, rawTargetY, targetSmooth);
  _camTargetSmZ = lerp(_camTargetSmZ || rawTargetZ, rawTargetZ, targetSmooth);

  // Final camera lerp (frame-rate independent)
  const posLerp = 1 - Math.pow(0.02, rawDt);
  const zoomLerp = 1 - Math.pow(0.04, rawDt);
  cameraX = lerp(cameraX, _camTargetSmX, posLerp);
  cameraY = lerp(cameraY, _camTargetSmY, posLerp);
  camZoom = lerp(camZoom, _camTargetSmZ, zoomLerp);
}

// â”€â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHUD() {} // HUD disabled

function makeHudShipEl(ship) {
  const el = document.createElement('div');
  el.className = 'hud-ship' + (ship.alive ? '' : ' dead');
  el.style.borderColor = ship.color + '55';
  el.appendChild(createShipIcon(ship.typeId, ship.color, 16));
  const name = document.createElement('span');
  name.className = 'hs-name';
  name.style.color = ship.color;
  name.textContent = ship.name;
  el.appendChild(name);
  if (ship.maxHp > 1) {
    const bar = document.createElement('div');
    bar.className = 'hs-hp-bar';
    const fill = document.createElement('div');
    fill.className = 'hs-hp-fill';
    fill.style.width = Math.max(0, (ship.hp / ship.maxHp) * 100) + '%';
    fill.style.background = ship.hp / ship.maxHp > 0.5 ? ship.color : ship.hp / ship.maxHp > 0.25 ? '#ffaa22' : '#ff4444';
    bar.appendChild(fill);
    el.appendChild(bar);
  }
  const kills = document.createElement('span');
  kills.className = 'hs-kills';
  kills.style.color = ship.color;
  kills.textContent = ship.kills || '';
  el.appendChild(kills);
  return el;
}
function render() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  // Camera transform
  ctx.translate(W / 2 + screenShakeX, H / 2 + screenShakeY);
  ctx.scale(camZoom, camZoom);
  ctx.translate(-cameraX, -cameraY);

  // Scale glow inversely with zoom â€” 1x at close, ~2x when zoomed out
  const baseGlowScale = Math.min(8, 0.35 / camZoom);
  // Countdown glow boost: 2Ã— at start, decaying to 1Ã— by end
  const countdownGlowMult = countdown ? 1 + (countdownTimer / COUNTDOWN_DURATION) : 1;
  const glowScale = baseGlowScale * countdownGlowMult;

  // Stars (parallax)
  drawStars();

  // Death glows â€” fading radial tint at kill sites
  for (const g of deathGlows) {
    const alpha = (g.life / g.maxLife) * 0.25;
    const radius = 200 + (1 - g.life / g.maxLife) * 100; // expand slightly as it fades
    const grad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, radius);
    grad.addColorStop(0, g.color);
    grad.addColorStop(1, 'transparent');
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grad;
    ctx.fillRect(g.x - radius, g.y - radius, radius * 2, radius * 2);
  }
  ctx.globalAlpha = 1;

  // Shockwaves
  for (const s of shockwaves) {
    const alpha = s.life / (s.maxLife || 0.4);
    ctx.save();
    ctx.globalAlpha = alpha * 0.6;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    if (s.ellipse) {
      // Elliptical shockwave (Fierce passive) â€” thin perpendicular to ship direction
      ctx.translate(s.x, s.y);
      ctx.rotate(s.ellipseAng);
      ctx.beginPath();
      ctx.ellipse(0, 0, s.r * 0.3, s.r, 0, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Asteroids
  for (const ast of asteroids) {
    // Visible on screen?
    const sx = (ast.x - cameraX) * camZoom + W/2;
    const sy = (ast.y - cameraY) * camZoom + H/2;
    const sr = ast.r * camZoom;
    if (sx < -sr*2 || sx > W+sr*2 || sy < -sr*2 || sy > H+sr*2) continue;

    ctx.save();
    ctx.translate(ast.x, ast.y);
    ctx.rotate(ast.rot);
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(ast.verts[0].x, ast.verts[0].y);
    for (let i = 1; i < ast.verts.length; i++) {
      ctx.lineTo(ast.verts[i].x, ast.verts[i].y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fill();
    ctx.restore();
  }

  // Debris field (Dump Debris) â€” rendered as squares
  ctx.shadowBlur = 0;
  for (const d of debrisField) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.life * 3); // slow tumble
    ctx.globalAlpha = Math.min(1, d.life * 0.8);
    ctx.fillStyle = d.color;
    const hs = d.size * 0.5;
    ctx.fillRect(-hs, -hs, d.size, d.size);
    ctx.restore();
  }

  // Ship clones (Double Team)
  for (const clone of shipClones) {
    if (!clone.alive) continue;
    ctx.save();
    if (clone.hit) {
      // Flash rapidly when hit
      ctx.globalAlpha = Math.sin(gameTime * 30) > 0 ? 0.8 : 0.15;
    } else if (clone.orbitElapsed < 0.5) {
      // Hologram flicker on spawn â€” rapid on/off
      const t = clone.orbitElapsed;
      const flicker = Math.sin(t * 60) * Math.sin(t * 23) * Math.sin(t * 47);
      ctx.globalAlpha = flicker > 0 ? 0.8 : 0.05;
    } else {
      ctx.globalAlpha = 0.7;
    }
    drawShipShape(ctx, clone.x, clone.y, clone.ang, clone.r, clone.color, 1, 1, 0, clone.shipId, 0);
    ctx.restore();
  }

  // Ship drones (Drone Array) â€” small pentagons
  for (const d of shipDrones) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.ang);
    const ds = (d._drawScale || 1) * d.r;
    ctx.fillStyle = d.color + '88';
    ctx.strokeStyle = d.color;
    ctx.shadowColor = d.color;
    ctx.shadowBlur = (d.state === 'pursuing' ? 10 : 4) * glowScale;
    ctx.lineWidth = 1.2;
    // Pentagon
    ctx.beginPath();
    for (let v = 0; v < 5; v++) {
      const a = (v / 5) * Math.PI * 2 - Math.PI / 2;
      const px = Math.cos(a) * ds, py = Math.sin(a) * ds;
      if (v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Ship drones (Drone Array) â€” small pentagons
  for (const d of shipDrones) {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.ang);
    const ds = (d._drawScale || 1) * d.r;
    ctx.fillStyle = d.color + '88';
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 1.2;
    ctx.shadowColor = d.color;
    ctx.shadowBlur = (d.state === 'pursuing' ? 10 : 5) * glowScale;
    ctx.beginPath();
    for (let p = 0; p < 5; p++) {
      const a = (p / 5) * Math.PI * 2 - Math.PI / 2;
      const px = Math.cos(a) * ds, py = Math.sin(a) * ds;
      if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Inner dot when armed/pursuing
    if (d.state !== 'orbiting') {
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(0, 0, ds * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Mines (Mine Field) â€” flashing stationary projectiles
  for (const mine of mines) {
    ctx.save();
    const armed = !mine.armTimer || mine.armTimer <= 0;
    // Flash: bright pulse every 1 second (only when armed)
    const flash = armed && Math.sin(gameTime * Math.PI) > 0.7;
    ctx.fillStyle = mine.color;
    ctx.shadowColor = mine.color;
    ctx.shadowBlur = (flash ? 20 : armed ? 6 : 2) * glowScale;
    ctx.globalAlpha = flash ? 1.0 : armed ? 0.6 : 0.25;
    ctx.beginPath();
    ctx.arc(mine.x, mine.y, mine.r, 0, Math.PI * 2);
    ctx.fill();
    // Inner dot
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = flash ? 0.9 : armed ? 0.3 : 0.1;
    ctx.beginPath();
    ctx.arc(mine.x, mine.y, mine.r * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Reflector shields â€” glowing lines orbiting the ship
  for (const rs of reflectorShields) {
    ctx.save();
    ctx.strokeStyle = rs.color;
    ctx.shadowColor = rs.color;
    ctx.shadowBlur = (12) * glowScale;
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.85;
    const cosA = Math.cos(rs.ang), sinA = Math.sin(rs.ang);
    ctx.beginPath();
    ctx.moveTo(rs.cx - cosA * rs.halfLength, rs.cy - sinA * rs.halfLength);
    ctx.lineTo(rs.cx + cosA * rs.halfLength, rs.cy + sinA * rs.halfLength);
    ctx.stroke();
    // Thicker inner glow
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    ctx.shadowBlur = (20) * glowScale;
    ctx.stroke();
    ctx.restore();
  }

  // Bullets
  for (const b of bullets) {
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = (b.ownerPassive === 'sparkDrive' ? 28 : 14) * glowScale;
    if (b.type === 'sniper') {
      // Beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (8) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.35;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2.5 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        // Connect last trail point to bullet
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      // Elongated bright line for sniper bullet head
      ctx.shadowBlur = (14) * glowScale;
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*10, b.y - Math.sin(bAng)*10);
      ctx.lineTo(b.x + Math.cos(bAng)*10, b.y + Math.sin(bAng)*10);
      ctx.stroke();
    } else if (b.type === 'alternating') {
      // Parallel laser lines
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*7, b.y - Math.sin(bAng)*7);
      ctx.lineTo(b.x + Math.cos(bAng)*7, b.y + Math.sin(bAng)*7);
      ctx.stroke();
    } else if (b.type === 'homing' && !b.isShrapnel) {
      // Diamond shape for missiles
      const bAng = Math.atan2(b.vy, b.vx);
      const sz = b.armed ? 5 : 3;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(bAng)*sz, b.y + Math.sin(bAng)*sz);
      ctx.lineTo(b.x + Math.cos(bAng+Math.PI/2)*sz*0.4, b.y + Math.sin(bAng+Math.PI/2)*sz*0.4);
      ctx.lineTo(b.x - Math.cos(bAng)*sz*0.6, b.y - Math.sin(bAng)*sz*0.6);
      ctx.lineTo(b.x + Math.cos(bAng-Math.PI/2)*sz*0.4, b.y + Math.sin(bAng-Math.PI/2)*sz*0.4);
      ctx.closePath();
      ctx.fill();
    } else if (b.type === 'chaotic' && b.trail && b.trail.length > 0) {
      // Chaotic: perpendicular line trails
      for (const tp of b.trail) {
        const alpha = tp.life / 0.25;
        const perp = tp.ang + Math.PI / 2;
        const len = 6 + 4 * alpha;
        ctx.globalAlpha = alpha * 0.7;
        ctx.strokeStyle = b.color;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(tp.x - Math.cos(perp) * len, tp.y - Math.sin(perp) * len);
        ctx.lineTo(tp.x + Math.cos(perp) * len, tp.y + Math.sin(perp) * len);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      // Bullet dot
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (b.type === 'triple') {
      // Short line for triple-guns
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*5, b.y - Math.sin(bAng)*5);
      ctx.lineTo(b.x + Math.cos(bAng)*5, b.y + Math.sin(bAng)*5);
      ctx.stroke();
    } else if (b.type === 'doublehelix') {
      // Cross-link trail lines between helix pair
      if (b.trail && b.trail.length > 0 && b.helixSide === 1) {
        for (const tp of b.trail) {
          const alpha = tp.life / 0.3;
          ctx.globalAlpha = alpha * 0.5;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(tp.x - Math.cos(tp.ang) * tp.len, tp.y - Math.sin(tp.ang) * tp.len);
          ctx.lineTo(tp.x + Math.cos(tp.ang) * tp.len, tp.y + Math.sin(tp.ang) * tp.len);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (b.type === 'crossshot') {
      // Beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (6) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.25;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      // Short laser line head
      ctx.shadowBlur = (14) * glowScale;
      const bAng = Math.atan2(b.vy, b.vx);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(b.x - Math.cos(bAng)*6, b.y - Math.sin(bAng)*6);
      ctx.lineTo(b.x + Math.cos(bAng)*6, b.y + Math.sin(bAng)*6);
      ctx.stroke();
    } else if (b.type === 'lightning') {
      // Lightning: jagged beam trail
      if (b.trail && b.trail.length > 1) {
        ctx.shadowBlur = (10) * glowScale;
        for (let t = 1; t < b.trail.length; t++) {
          const alpha = b.trail[t].life / 0.4;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = b.color;
          ctx.lineWidth = 2.5 * alpha;
          ctx.beginPath();
          ctx.moveTo(b.trail[t-1].x, b.trail[t-1].y);
          ctx.lineTo(b.trail[t].x, b.trail[t].y);
          ctx.stroke();
        }
        const last = b.trail[b.trail.length - 1];
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      // Bright point at tip
      ctx.shadowBlur = (18) * glowScale;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      if (b.ownerPassive === 'piercing') {
        // Piercing: pointed triangle bullet
        const bAng = Math.atan2(b.vy, b.vx);
        const sz = b.size || 3;
        ctx.beginPath();
        ctx.moveTo(b.x + Math.cos(bAng) * sz * 1.5, b.y + Math.sin(bAng) * sz * 1.5);
        ctx.lineTo(b.x + Math.cos(bAng + 2.4) * sz, b.y + Math.sin(bAng + 2.4) * sz);
        ctx.lineTo(b.x + Math.cos(bAng - 2.4) * sz, b.y + Math.sin(bAng - 2.4) * sz);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.shadowBlur = 0;
  }

  // Orphan lightning trails (persist after bullet death)
  for (const ot of orphanTrails) {
    if (ot.trail.length < 2) continue;
    ctx.shadowColor = ot.color;
    ctx.shadowBlur = (10) * glowScale;
    for (let t = 1; t < ot.trail.length; t++) {
      const alpha = ot.trail[t].life / 0.4;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = ot.color;
      ctx.lineWidth = 2.5 * alpha;
      ctx.beginPath();
      ctx.moveTo(ot.trail[t-1].x, ot.trail[t-1].y);
      ctx.lineTo(ot.trail[t].x, ot.trail[t].y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }

  // Ships
  for (const ship of ships) {
    if (!ship.alive) continue;
    if (ship._teleportPhase === 'phasing') continue; // invisible during teleport

    // â”€â”€ STEALTH BEAM TRAIL (draw before ship) â”€â”€
    if (ship.passive === 'stealth' && ship.beamTrail && ship.beamTrail.length > 1) {
      ctx.save();
      ctx.shadowColor = ship.color;
      ctx.shadowBlur = (6) * glowScale;
      for (let t = 1; t < ship.beamTrail.length; t++) {
        const alpha = ship.beamTrail[t].life / ship.beamTrail[t].maxLife;
        ctx.globalAlpha = alpha * 0.5;
        ctx.strokeStyle = ship.color;
        ctx.lineWidth = 2.5 * alpha;
        ctx.beginPath();
        ctx.moveTo(ship.beamTrail[t-1].x, ship.beamTrail[t-1].y);
        ctx.lineTo(ship.beamTrail[t].x, ship.beamTrail[t].y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Zoom-dependent glow ring â€” visible at distance, fades when close
    const zoomRingAlpha = Math.max(0, Math.min(0.35, (0.5 - camZoom) * 1));
    if (zoomRingAlpha > 0.01) {
      const ringR = ship.r * 6;
      const hc = ship.color;
      const r = parseInt(hc.slice(1,3),16), g = parseInt(hc.slice(3,5),16), bl = parseInt(hc.slice(5,7),16);
      const grad = ctx.createRadialGradient(ship.x, ship.y, ship.r * 0.5, ship.x, ship.y, ringR);
      grad.addColorStop(0, `rgba(${r},${g},${bl},${zoomRingAlpha})`);
      grad.addColorStop(0.3, `rgba(${r},${g},${bl},${zoomRingAlpha * 0.5})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(ship.x, ship.y, ringR, 0, Math.PI * 2);
      ctx.fill();
    }

    drawShipShape(ctx, ship.x, ship.y, ship.ang, ship.r, ship.color, ship.hp, ship.maxHp, ship.invuln, ship.typeId, ship.hpBarTimer);

    // â”€â”€ PASSIVE VISUAL OVERLAYS â”€â”€
    ctx.save();

    // Shield: hex ring around ship until damaged
    if (ship.passive === 'shield' && ship.shieldActive) {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      const shieldR = (ship.r + 6) * 1.2;
      const pulse = 0.35 + 0.15 * Math.sin(gameTime * 3);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = pulse;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let v = 0; v < 6; v++) {
        const a = (v / 6) * Math.PI * 2 - Math.PI / 6;
        const px = Math.cos(a) * shieldR, py = Math.sin(a) * shieldR;
        if (v === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Titanium: two shield-like chevrons on each side of the ship
    if (ship.passive === 'titanium') {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = 0.25 + 0.05 * Math.sin(gameTime * 2);
      ctx.lineWidth = 1.4;
      const cR = ship.r + 6;
      for (const side of [-1, 1]) {
        // Very obtuse (~155Â°) chevron pointing sideways like a shield bracket
        ctx.beginPath();
        ctx.moveTo(cR * 0.8, side * cR * 0.95);    // front arm
        ctx.lineTo(0, side * cR * 1.15);             // outward tip
        ctx.lineTo(-cR * 0.8, side * cR * 0.95);    // rear arm
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Drillbore: small chevron on the front of the ship's nose
    if (ship.passive === 'drillbore') {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.ang);
      ctx.strokeStyle = ship.color;
      ctx.globalAlpha = 0.6;
      ctx.lineWidth = 1.8;
      const noseOff = ship.r + 4;
      ctx.beginPath();
      ctx.moveTo(noseOff - 4, -5);
      ctx.lineTo(noseOff + 2, 0);
      ctx.lineTo(noseOff - 4, 5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    ctx.restore();
  }

  // Particles
  const _rvw = (W / camZoom) * 0.52, _rvh = (H / camZoom) * 0.52;
  for (const p of particles) {
    if (p.x < cameraX - _rvw || p.x > cameraX + _rvw || p.y < cameraY - _rvh || p.y > cameraY + _rvh) continue;
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    if (p.isArc && p.arcPoints) {
      // Mini lightning arc â€” jagged connected segments
      ctx.strokeStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 6 * glowScale;
      ctx.lineWidth = 1.5 * alpha;
      ctx.beginPath();
      ctx.moveTo(p.x + p.arcPoints[0].x, p.y + p.arcPoints[0].y);
      for (let a = 1; a < p.arcPoints.length; a++) {
        ctx.lineTo(p.x + p.arcPoints[a].x, p.y + p.arcPoints[a].y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (p.isLine) {
      // Line particle for debuff effects
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(p.x - Math.cos(p.lineAng) * p.lineLen * 0.5, p.y - Math.sin(p.lineAng) * p.lineLen * 0.5);
      ctx.lineTo(p.x + Math.cos(p.lineAng) * p.lineLen * 0.5, p.y + Math.sin(p.lineAng) * p.lineLen * 0.5);
      ctx.stroke();
    } else if (p.isDiamond) {
      // Diamond/rhombus crystal
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spinAng || 0);
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 5 * glowScale;
      ctx.strokeStyle = p.color;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha * 0.4;
      const s = p.size;
      ctx.beginPath();
      ctx.moveTo(0, -s);
      ctx.lineTo(s * 0.6, 0);
      ctx.lineTo(0, s);
      ctx.lineTo(-s * 0.6, 0);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if (p.isSnowflake) {
      // Six-pointed snowflake cross
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spinAng || 0);
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 5 * glowScale;
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1;
      const s = p.size;
      for (let arm = 0; arm < 6; arm++) {
        const a = (arm / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * s, Math.sin(a) * s);
        ctx.stroke();
        // Small barbs at 60% length
        const bx = Math.cos(a) * s * 0.6, by = Math.sin(a) * s * 0.6;
        const bLen = s * 0.3;
        const b1 = a + 0.5, b2 = a - 0.5;
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + Math.cos(b1) * bLen, by + Math.sin(b1) * bLen);
        ctx.moveTo(bx, by);
        ctx.lineTo(bx + Math.cos(b2) * bLen, by + Math.sin(b2) * bLen);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if (p.isPlus) {
      // Plus sign particle (Bio-Hull)
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1.5;
      const s = p.size * 0.6;
      ctx.beginPath();
      ctx.moveTo(p.x - s, p.y); ctx.lineTo(p.x + s, p.y);
      ctx.moveTo(p.x, p.y - s); ctx.lineTo(p.x, p.y + s);
      ctx.stroke();
    } else {
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // â”€â”€ ANIME FINALE EFFECTS â”€â”€
  if (finaleMode && finaleDeath) {
    const t = finaleTimer;

    // WHITE FLASH on impact
    if (finaleFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${finaleFlash * 0.9})`;
      ctx.fillRect(0, 0, W, H);
    }

    // Screen-space position of death
    const dx = (finaleDeath.x - cameraX) * camZoom + W/2;
    const dy = (finaleDeath.y - cameraY) * camZoom + H/2;

    // SPEED LINES radiating from kill point
    if (t < 3) {
      const lineAlpha = Math.max(0, 1 - t / 3);
      const numLines = 60;
      ctx.save();
      ctx.globalAlpha = lineAlpha * 0.6;
      for (let i = 0; i < numLines; i++) {
        const a = (i / numLines) * Math.PI * 2 + t * 0.3;
        const innerR = 40 + t * 100;
        const outerR = innerR + 200 + Math.random() * 300;
        const thickness = 1 + Math.random() * 2;
        ctx.strokeStyle = i % 3 === 0 ? finaleDeath.killerColor : (i % 3 === 1 ? '#fff' : finaleDeath.color);
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(dx + Math.cos(a) * innerR, dy + Math.sin(a) * innerR);
        ctx.lineTo(dx + Math.cos(a) * outerR, dy + Math.sin(a) * outerR);
        ctx.stroke();
      }
      ctx.restore();
    }

    // IMPACT RINGS
    if (t < 2) {
      const numRings = 3;
      for (let i = 0; i < numRings; i++) {
        const ringT = t - i * 0.15;
        if (ringT < 0) continue;
        const ringR = ringT * 400;
        const ringAlpha = Math.max(0, 1 - ringT / 1.5);
        ctx.strokeStyle = i === 0 ? '#fff' : finaleDeath.killerColor;
        ctx.globalAlpha = ringAlpha * 0.5;
        ctx.lineWidth = 3 - i;
        ctx.beginPath();
        ctx.arc(dx, dy, ringR, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // DRAMATIC VIGNETTE
    const vGrad = ctx.createRadialGradient(dx, dy, W * 0.1, W / 2, H / 2, W * 0.8);
    vGrad.addColorStop(0, 'transparent');
    vGrad.addColorStop(1, `rgba(0,0,0,${Math.min(0.7, t * 0.3)})`);
    ctx.fillStyle = vGrad;
    ctx.fillRect(0, 0, W, H);

    // WINNER TEXT â€” slides in after a beat
    if (t > 1.2) {
      const textT = t - 1.2;
      const textAlpha = Math.min(1, textT * 2);
      const slideX = Math.max(0, 30 - textT * 60);

      const w = ships.find(s => s.alive);
      if (w) {
        const winText = (matchMode === 'teams') ? teamNames[(w.team || 1) - 1] : w.name;
        const _cwcArr = getTeamColors();
        const winColor = (matchMode === 'teams') ? (_cwcArr[(w.team || 1) - 1] || w.color) : w.color;
        ctx.save();
        ctx.globalAlpha = textAlpha;

        // Glowing name
        ctx.font = '900 56px "Orbitron"';
        ctx.textAlign = 'center';
        ctx.shadowColor = winColor;
        ctx.shadowBlur = (40) * glowScale;
        ctx.fillStyle = winColor;
        ctx.fillText(winText, W/2 + slideX, H/2);
        ctx.shadowBlur = 0;

        // "WINS" subtitle
        ctx.font = '400 16px "Orbitron"';
        ctx.fillStyle = `rgba(255,255,255,${textAlpha * 0.6})`;
        ctx.letterSpacing = '12px';
        ctx.fillText('W I N S', W/2 + slideX, H/2 + 35);

        ctx.restore();
      } else {
        ctx.save();
        ctx.globalAlpha = textAlpha;
        ctx.font = '900 56px "Orbitron"';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#888';
        ctx.shadowBlur = (40) * glowScale;
        ctx.fillStyle = '#888';
        ctx.fillText('DRAW', W/2 + slideX, H/2);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Chromatic aberration-style color split on edges during the flash
    if (t < 0.5) {
      const abAmount = (0.5 - t) * 8;
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = (0.5 - t) * 0.3;
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(abAmount, 0, W, H);
      ctx.fillStyle = '#0000ff';
      ctx.fillRect(-abAmount, 0, W, H);
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }
  }

  // â”€â”€ SELECTION BOX â”€â”€
  if (isSelecting && selectBoxStart && selectBoxEnd) {
    const x = Math.min(selectBoxStart.x, selectBoxEnd.x);
    const y = Math.min(selectBoxStart.y, selectBoxEnd.y);
    const w = Math.abs(selectBoxEnd.x - selectBoxStart.x);
    const h = Math.abs(selectBoxEnd.y - selectBoxStart.y);
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(x, y, w, h);
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    ctx.fillRect(x, y, w, h);
  }

  // â”€â”€ SCOREBOARD HUD â”€â”€
  drawScoreboard(ctx);
}

// â”€â”€â”€ STARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let stars = [];
function initStars() {
  for (let i = 0; i < 700; i++) {
    stars.push({
      x: rand(0, CFG.WORLD_W),
      y: rand(0, CFG.WORLD_H),
      s: rand(0.5, 2),
      b: rand(0.4, 1.0),
    });
  }
}

function drawStars() {
  for (const star of stars) {
    ctx.fillStyle = `rgba(255,255,255,${star.b * (0.5 + 0.5 * Math.sin(gameTime * 0.5 + star.x))})`;
    ctx.fillRect(star.x, star.y, star.s, star.s);
  }
}

// â”€â”€â”€ SCOREBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€ KILLFEED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addKillMessage() {} // disabled â€” was covering action mid-match

// â”€â”€â”€ SCOREBOARD (canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildScoreboard() {}
function updateScoreboard() {}
function drawScoreboard(ctx) {} // HUD handled via DOM now

// â”€â”€â”€ MATCH FLOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildCountdownRoster() {
  const container = document.getElementById('cd-fighters');
  container.innerHTML = '';
  const titleEl = document.getElementById('cd-title');
  const chooseEl = document.getElementById('cd-choose');
  const betsEl = document.getElementById('cd-bets');

  if (matchMode === 'ffa') {
    titleEl.textContent = 'FREE FOR ALL';
    chooseEl.style.display = 'none';
    betsEl.style.display = 'none';
    const grid = document.createElement('div');
    grid.style.cssText = 'display:flex; flex-wrap:wrap; justify-content:center; gap:8px; padding:8px 0;';
    for (let si = 0; si < ships.length; si++) {
      const ship = ships[si];
      const ic = createShipIcon(ship.typeId, ship.color, 36);
      ic.style.animation = 'cdSlideIn 0.4s ease-out backwards';
      ic.style.animationDelay = `${si * 0.05}s`;
      grid.appendChild(ic);
    }
    container.appendChild(grid);
  } else {
    chooseEl.style.display = 'block';
    betsEl.style.display = 'block';
    const _tcArr = getTeamColors();
    const parts = teams.map((_, t) => `<span style="color:${_tcArr[t]}">${teamNames[t]}</span>`);
    titleEl.innerHTML = parts.join(' <span style="color:rgba(255,255,255,0.4)">vs</span> ');
    let delay = 0;
    for (let t = 0; t < teams.length; t++) {
      if (t > 0) {
        const vs = document.createElement('div');
        vs.style.cssText = 'text-align:center; font-family:Orbitron,sans-serif; font-size:clamp(12px,3.5vw,24px); font-weight:900; letter-spacing:4px; color:rgba(255,255,255,0.5); margin:6px 0;';
        vs.textContent = 'VS';
        container.appendChild(vs);
      }
      // Team name label
      const label = document.createElement('div');
      label.style.cssText = `text-align:center; font-family:Orbitron,sans-serif; font-size:clamp(11px,3vw,18px); font-weight:700; letter-spacing:3px; color:${_tcArr[t] || '#fff'}; margin:4px 0 2px 0;`;
      label.textContent = teamNames[t];
      container.appendChild(label);
      // Horizontal icon grid
      const grid = document.createElement('div');
      grid.style.cssText = 'display:flex; flex-wrap:wrap; justify-content:center; gap:6px; padding:2px 0;';
      const teamShips = ships.filter(s => s.team === t + 1);
      for (let si = 0; si < teamShips.length; si++) {
        const ship = teamShips[si];
        const ic = createShipIcon(ship.typeId, ship.color, 32);
        ic.style.animation = 'cdSlideIn 0.4s ease-out backwards';
        ic.style.animationDelay = `${delay++ * 0.04}s`;
        grid.appendChild(ic);
      }
      container.appendChild(grid);
    }
  }

  // Scale to fit without scrollbar
  requestAnimationFrame(() => {
    const overlay = document.getElementById('countdown-overlay');
    const avail = overlay.clientHeight * 0.82; // leave room for title + timer
    const natural = container.scrollHeight;
    if (natural > avail && natural > 0) {
      const scale = Math.max(0.35, avail / natural);
      container.style.transform = `scale(${scale})`;
      container.style.transformOrigin = 'top center';
      container.style.height = `${avail}px`;
    } else {
      container.style.transform = '';
      container.style.height = '';
    }
  });
}

function launchMatch() {
  ensureAudio();
  init();
  pregame = false;
  document.getElementById('setup-screen').classList.add('hidden');
  countdown = true;
  countdownTimer = COUNTDOWN_DURATION;
  buildCountdownRoster();
  document.getElementById('countdown-overlay').classList.remove('hidden');
}

function showWinner() {
  const ov = document.getElementById('winner-overlay');
  ov.classList.add('show');
  document.getElementById('match-hud').classList.remove('active');
  showScoreboard = false;

  const nameEl = document.getElementById('winner-name');
  const labelEl = document.getElementById('winner-label');

  if (matchMode === 'ffa') {
    const survivor = ships.find(s => s.alive);
    if (survivor) {
      labelEl.textContent = 'WINNER';
      nameEl.textContent = survivor.name;
      nameEl.style.color = survivor.color;
    } else {
      labelEl.textContent = 'RESULT';
      nameEl.textContent = 'DRAW';
      nameEl.style.color = '#888';
    }
  } else {
    const _wcArr = getTeamColors();
    const teamsAlive = [...new Set(ships.filter(s => s.alive && s.team > 0).map(s => s.team))];
    if (teamsAlive.length === 1) {
      const wt = teamsAlive[0];
      labelEl.textContent = 'WINNER';
      nameEl.textContent = teamNames[wt - 1];
      nameEl.style.color = _wcArr[wt - 1] || '#fff';
    } else {
      labelEl.textContent = 'RESULT';
      nameEl.textContent = 'DRAW';
      nameEl.style.color = '#888';
    }
  }

  // Build rankings
  const container = document.getElementById('rankings');
  container.innerHTML = '';

  function fmtTime(t) {
    if (t === null) return 'â€”';
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  if (matchMode === 'teams') {
    // Team-level results
    const _rcArr = getTeamColors();
    const teamStats = [];
    for (let t = 0; t < teams.length; t++) {
      const teamShips = ships.filter(s => s.team === t + 1);
      const totalKills = teamShips.reduce((s, sh) => s + (sh.kills || 0), 0);
      const lastDeath = Math.max(...teamShips.map(s => s.alive ? gameTime : (s.deathTime || 0)));
      const anyAlive = teamShips.some(s => s.alive);
      teamStats.push({ idx: t, teamShips, totalKills, lastDeath, anyAlive });
    }
    // Sort: alive teams first, then by last death time desc
    teamStats.sort((a, b) => {
      if (a.anyAlive && !b.anyAlive) return -1;
      if (!a.anyAlive && b.anyAlive) return 1;
      return b.lastDeath - a.lastDeath;
    });

    teamStats.forEach((ts, rank) => {
      const card = document.createElement('div');
      card.className = 'result-card';
      card.style.cssText = 'flex-direction:column; align-items:center; padding:8px 12px; gap:4px;';
      card.style.animationDelay = `${rank * 0.15}s`;

      // Rank + team name row
      const header = document.createElement('div');
      header.style.cssText = 'display:flex; align-items:center; gap:8px; width:100%;';
      const rankEl = document.createElement('span');
      rankEl.className = 'rc-rank';
      rankEl.textContent = rank + 1;
      header.appendChild(rankEl);
      const nameEl = document.createElement('span');
      nameEl.className = 'rc-name';
      nameEl.style.color = _rcArr[ts.idx] || '#fff';
      nameEl.style.flex = '1';
      nameEl.textContent = teamNames[ts.idx];
      header.appendChild(nameEl);
      // Stats
      const statsDiv = document.createElement('div');
      statsDiv.className = 'rc-stats-col';
      const kills = document.createElement('span');
      kills.className = 'rc-stats';
      kills.style.color = _rcArr[ts.idx] || '#fff';
      kills.textContent = `${ts.totalKills} kill${ts.totalKills === 1 ? '' : 's'}`;
      statsDiv.appendChild(kills);
      const time = document.createElement('div');
      time.className = 'rc-cause';
      time.textContent = ts.anyAlive ? `survived ${fmtTime(gameTime)}` : `eliminated ${fmtTime(ts.lastDeath)}`;
      statsDiv.appendChild(time);
      header.appendChild(statsDiv);
      card.appendChild(header);

      // Ship icons row
      const icons = document.createElement('div');
      icons.style.cssText = 'display:flex; flex-wrap:wrap; justify-content:center; gap:6px; padding:4px 0;';
      for (const ship of ts.teamShips) {
        const ic = createShipIcon(ship.typeId, ship.color, 37);
        if (!ship.alive) ic.style.opacity = '0.3';
        icons.appendChild(ic);
      }
      card.appendChild(icons);

      container.appendChild(card);
    });
  } else {
    // FFA: individual ship results
    const ranked = [...ships].sort((a, b) => {
      if (a.alive && !b.alive) return -1;
      if (!a.alive && b.alive) return 1;
      return (b.deathTime || 0) - (a.deathTime || 0);
    });

    ranked.forEach((ship, i) => {
      const card = document.createElement('div');
      card.className = 'result-card';
      card.style.animationDelay = `${i * 0.1}s`;

      const rank = document.createElement('span');
      rank.className = 'rc-rank';
      rank.textContent = i + 1;
      card.appendChild(rank);

      card.appendChild(createShipIcon(ship.typeId, ship.color, 48));

      const info = document.createElement('div');
      info.className = 'rc-info';
      const name = document.createElement('span');
      name.className = 'rc-name';
      name.style.color = ship.color;
      name.textContent = ship.name;
      info.appendChild(name);
      const loadout = document.createElement('span');
      loadout.className = 'rc-loadout';
      const wpn = ship.weapon?.name || 'Basic';
      const pas = PASSIVE_DEFS[ship.passive]?.name || 'None';
      loadout.textContent = `${wpn} Â· ${pas}`;
      info.appendChild(loadout);
      card.appendChild(info);

      const statsDiv = document.createElement('div');
      statsDiv.className = 'rc-stats-col';
      const stats = document.createElement('span');
      stats.className = 'rc-stats';
      stats.style.color = ship.color;
      stats.textContent = `${ship.kills || 0} kill${ship.kills === 1 ? '' : 's'}`;
      statsDiv.appendChild(stats);
      const cause = document.createElement('div');
      cause.className = 'rc-cause';
      const survivalTime = ship.alive ? gameTime : ship.deathTime;
      cause.textContent = ship.alive ? `survived ${fmtTime(survivalTime)}` : `âœ• ${ship.killedBy} at ${fmtTime(ship.deathTime)}`;
      statsDiv.appendChild(cause);
      card.appendChild(statsDiv);

      container.appendChild(card);
    });
  }

  // Scale to fit without scrollbar
  requestAnimationFrame(() => {
    const ov = document.getElementById('winner-overlay');
    const rankings = document.getElementById('rankings');
    // Available height = overlay minus header/buttons
    const headerH = (document.getElementById('winner-label')?.offsetHeight || 0) +
                     (document.getElementById('winner-name')?.offsetHeight || 0) + 40;
    const buttonsH = document.querySelector('.win-buttons')?.offsetHeight || 50;
    const avail = ov.clientHeight - headerH - buttonsH - 40;
    const natural = rankings.scrollHeight;
    if (natural > avail && natural > 0) {
      const scale = Math.max(0.3, avail / natural);
      rankings.style.transform = `scale(${scale})`;
      rankings.style.transformOrigin = 'top center';
      rankings.style.height = `${avail}px`;
    } else {
      rankings.style.transform = '';
      rankings.style.height = '';
    }
  });
}

function rematch() {
  document.getElementById('winner-overlay').classList.remove('show');
  document.getElementById('killfeed').innerHTML = '';
  init();
  pregame = false;
  countdown = true;
  countdownTimer = COUNTDOWN_DURATION;
  buildCountdownRoster();
  document.getElementById('countdown-overlay').classList.remove('hidden');
}

function newSetup() {
  document.getElementById('winner-overlay').classList.remove('show');
  document.getElementById('match-hud').classList.remove('active');
  document.getElementById('killfeed').innerHTML = '';
  pregame = true;
  gameOver = false;
  teams = [[], []];
  teamNames = ['TEAM 1', 'TEAM 2'];
  teamWeapons = [[], []];
  teamPassives = [[], []];
  teamManeuvers = [[], []];
  selectedShips = [];
  document.getElementById('setup-screen').classList.remove('hidden');
  renderSetup();
}

// â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = 0;
function gameLoop(time) {
  const rawDt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(rawDt);
  render();
  requestAnimationFrame(gameLoop);
}

// â”€â”€â”€ INIT APP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
initStars();
buildHPRow();
// Auto-fill for quick start
autoFill();
requestAnimationFrame(gameLoop);

// â”€â”€â”€ REGISTER SERVICE WORKER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(() => {});
}

</script>
</body>
</html>
